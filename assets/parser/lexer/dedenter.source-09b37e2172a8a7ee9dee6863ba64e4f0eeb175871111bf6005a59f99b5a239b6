/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $slice = Opal.slice;

  Opal.add_stubs(['$encoding', '$split', '$force_encoding', '$map!', '$each', '$each_char', '$<=', '$===', '$+', '$-', '$>', '$*', '$/', '$slice!', '$replace', '$join', '$end_with?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Dedenter');

      var $nesting = [self].concat($parent_nesting), $Dedenter_initialize$1, $Dedenter_dedent$2, $Dedenter_interrupt$6;

      self.$$prototype.at_line_begin = nil;
      
      Opal.const_set($nesting[0], 'TAB_WIDTH', 8);
      
      Opal.def(self, '$initialize', $Dedenter_initialize$1 = function $$initialize(dedent_level) {
        var self = this;

        
        self.dedent_level = dedent_level;
        self.at_line_begin = true;
        return (self.indent_level = 0);
      }, $Dedenter_initialize$1.$$arity = 1);
      
      Opal.def(self, '$dedent', $Dedenter_dedent$2 = function $$dedent(string) {
        var $$3, $a, $b, $$4, self = this, original_encoding = nil, lines = nil, lines_to_dedent = nil, _first = nil;

        
        original_encoding = string.$encoding();
        lines = string.$force_encoding($$$($$($nesting, 'Encoding'), 'BINARY')).$split("\\\n");
        $send(lines, 'map!', [], ($$3 = function(s){var self = $$3.$$s == null ? this : $$3.$$s;

        
          
          if (s == null) {
            s = nil;
          };
          return s.$force_encoding(original_encoding);}, $$3.$$s = self, $$3.$$arity = 1, $$3));
        if ($truthy(self.at_line_begin)) {
          lines_to_dedent = lines
        } else {
          $b = lines, $a = Opal.to_ary($b), (_first = ($a[0] == null ? nil : $a[0])), (lines_to_dedent = $slice.call($a, 1)), $b
        };
        (function(){var $brk = Opal.new_brk(); try {return $send(lines_to_dedent, 'each', [], ($$4 = function(line){var self = $$4.$$s == null ? this : $$4.$$s, $$5, left_to_remove = nil, remove = nil;
          if (self.dedent_level == null) self.dedent_level = nil;

        
          
          if (line == null) {
            line = nil;
          };
          left_to_remove = self.dedent_level;
          remove = 0;
          (function(){var $brk = Opal.new_brk(); try {return $send(line, 'each_char', [], ($$5 = function(char$){var self = $$5.$$s == null ? this : $$5.$$s, $case = nil;
            if (self.dedent_level == null) self.dedent_level = nil;

          
            
            if (char$ == null) {
              char$ = nil;
            };
            if ($truthy($rb_le(left_to_remove, 0))) {
              
              Opal.brk(nil, $brk)};
            return (function() {$case = char$;
            if (" "['$===']($case)) {
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, 1));}
            else if ("\t"['$===']($case)) {
            if ($truthy($rb_gt($rb_times($$($nesting, 'TAB_WIDTH'), $rb_plus($rb_divide(remove, $$($nesting, 'TAB_WIDTH')), 1)), self.dedent_level))) {
              
              Opal.brk(nil, $brk)};
            remove = $rb_plus(remove, 1);
            return (left_to_remove = $rb_minus(left_to_remove, $$($nesting, 'TAB_WIDTH')));}
            else {
            Opal.brk(nil, $brk)}})();}, $$5.$$s = self, $$5.$$brk = $brk, $$5.$$arity = 1, $$5))
          } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
          return line['$slice!'](0, remove);}, $$4.$$s = self, $$4.$$brk = $brk, $$4.$$arity = 1, $$4))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
        string.$replace(lines.$join());
        return (self.at_line_begin = string['$end_with?']("\n"));
      }, $Dedenter_dedent$2.$$arity = 1);
      return (Opal.def(self, '$interrupt', $Dedenter_interrupt$6 = function $$interrupt() {
        var self = this;

        return (self.at_line_begin = false)
      }, $Dedenter_interrupt$6.$$arity = 0), nil) && 'interrupt';
    })($$($nesting, 'Lexer'), null, $nesting)
  })($nesting[0], $nesting)
})(Opal);
