/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$default_parser', '$setup_source_buffer', '$default_encoding', '$parse', '$parse_with_comments', '$read', '$new', '$all_errors_are_fatal=', '$diagnostics', '$-', '$ignore_warnings=', '$lambda', '$puts', '$render', '$consumer=', '$force_encoding', '$dup', '$==', '$name', '$raw_source=', '$source=', '$private_class_method', '$attr_reader', '$version', '$diagnostics=', '$static_env=', '$context=', '$parser=', '$class', '$[]', '$reset', '$source_buffer=', '$do_parse', '$comments=', '$comments', '$tokens=', '$!', '$raise', '$tokens', '$private', '$advance', '$===', '$diagnostic', '$map', '$process', '$yyerror', '$token_to_str']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Base');

      var $nesting = [self].concat($parent_nesting), $Base_parse$1, $Base_parse_with_comments$2, $Base_parse_file$3, $Base_parse_file_with_comments$4, $Base_default_parser$5, $Base_setup_source_buffer$7, $Base_initialize$8, $Base_reset$9, $Base_parse$10, $Base_parse_with_comments$11, $Base_tokenize$12, $Base_next_token$13, $Base_check_kwarg_name$14, $Base_diagnostic$15, $Base_on_error$17;

      self.$$prototype.diagnostics = self.$$prototype.lexer = self.$$prototype.static_env = self.$$prototype.context = self.$$prototype.builder = self.$$prototype.current_arg_stack = self.$$prototype.pattern_variables = self.$$prototype.pattern_hash_keys = nil;
      
      Opal.defs(self, '$parse', $Base_parse$1 = function $$parse(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        
        if (file == null) {
          file = "(string)";
        };
        
        if (line == null) {
          line = 1;
        };
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse(source_buffer);
      }, $Base_parse$1.$$arity = -2);
      Opal.defs(self, '$parse_with_comments', $Base_parse_with_comments$2 = function $$parse_with_comments(string, file, line) {
        var self = this, parser = nil, source_buffer = nil;

        
        
        if (file == null) {
          file = "(string)";
        };
        
        if (line == null) {
          line = 1;
        };
        parser = self.$default_parser();
        source_buffer = self.$setup_source_buffer(file, line, string, parser.$default_encoding());
        return parser.$parse_with_comments(source_buffer);
      }, $Base_parse_with_comments$2.$$arity = -2);
      Opal.defs(self, '$parse_file', $Base_parse_file$3 = function $$parse_file(filename) {
        var self = this;

        return self.$parse($$($nesting, 'File').$read(filename), filename)
      }, $Base_parse_file$3.$$arity = 1);
      Opal.defs(self, '$parse_file_with_comments', $Base_parse_file_with_comments$4 = function $$parse_file_with_comments(filename) {
        var self = this;

        return self.$parse_with_comments($$($nesting, 'File').$read(filename), filename)
      }, $Base_parse_file_with_comments$4.$$arity = 1);
      Opal.defs(self, '$default_parser', $Base_default_parser$5 = function $$default_parser() {
        var $$6, self = this, parser = nil, $writer = nil;

        
        parser = self.$new();
        
        $writer = [true];
        $send(parser.$diagnostics(), 'all_errors_are_fatal=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [true];
        $send(parser.$diagnostics(), 'ignore_warnings=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [$send(self, 'lambda', [], ($$6 = function(diagnostic){var self = $$6.$$s == null ? this : $$6.$$s;
          if ($gvars.stderr == null) $gvars.stderr = nil;

        
          
          if (diagnostic == null) {
            diagnostic = nil;
          };
          return $gvars.stderr.$puts(diagnostic.$render());}, $$6.$$s = self, $$6.$$arity = 1, $$6))];
        $send(parser.$diagnostics(), 'consumer=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return parser;
      }, $Base_default_parser$5.$$arity = 0);
      Opal.defs(self, '$setup_source_buffer', $Base_setup_source_buffer$7 = function $$setup_source_buffer(file, line, string, encoding) {
        var self = this, source_buffer = nil, $writer = nil;

        
        string = string.$dup().$force_encoding(encoding);
        source_buffer = $$$($$($nesting, 'Source'), 'Buffer').$new(file, line);
        if (self.$name()['$==']("Parser::Ruby18")) {
          
          $writer = [string];
          $send(source_buffer, 'raw_source=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        } else {
          
          $writer = [string];
          $send(source_buffer, 'source=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];
        };
        return source_buffer;
      }, $Base_setup_source_buffer$7.$$arity = 4);
      self.$private_class_method("setup_source_buffer");
      self.$attr_reader("lexer");
      self.$attr_reader("diagnostics");
      self.$attr_reader("builder");
      self.$attr_reader("static_env");
      self.$attr_reader("source_buffer");
      self.$attr_reader("context");
      self.$attr_reader("max_numparam_stack");
      self.$attr_reader("current_arg_stack");
      self.$attr_reader("pattern_variables");
      self.$attr_reader("pattern_hash_keys");
      
      Opal.def(self, '$initialize', $Base_initialize$8 = function $$initialize(builder) {
        var self = this, $writer = nil, $ret_or_1 = nil;

        
        
        if (builder == null) {
          builder = $$$($$$($$($nesting, 'Parser'), 'Builders'), 'Default').$new();
        };
        self.diagnostics = $$$($$($nesting, 'Diagnostic'), 'Engine').$new();
        self.static_env = $$($nesting, 'StaticEnvironment').$new();
        self.context = $$($nesting, 'Context').$new();
        self.max_numparam_stack = $$($nesting, 'MaxNumparamStack').$new();
        self.current_arg_stack = $$($nesting, 'CurrentArgStack').$new();
        self.pattern_variables = $$($nesting, 'VariablesStack').$new();
        self.pattern_hash_keys = $$($nesting, 'VariablesStack').$new();
        self.lexer = $$($nesting, 'Lexer').$new(self.$version());
        
        $writer = [self.diagnostics];
        $send(self.lexer, 'diagnostics=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [self.static_env];
        $send(self.lexer, 'static_env=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [self.context];
        $send(self.lexer, 'context=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.builder = builder;
        
        $writer = [self];
        $send(self.builder, 'parser=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.last_token = nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = $$$(self.$class(), 'Racc_debug_parser')))) {
          return $$($nesting, 'ENV')['$[]']("RACC_DEBUG")
        } else {
          return $ret_or_1
        }; return nil; })())) {
          self.yydebug = true};
        return self.$reset();
      }, $Base_initialize$8.$$arity = -1);
      
      Opal.def(self, '$reset', $Base_reset$9 = function $$reset() {
        var self = this;

        
        self.source_buffer = nil;
        self.lexer.$reset();
        self.static_env.$reset();
        self.context.$reset();
        self.current_arg_stack.$reset();
        self.pattern_variables.$reset();
        self.pattern_hash_keys.$reset();
        return self;
      }, $Base_reset$9.$$arity = 0);
      
      Opal.def(self, '$parse', $Base_parse$10 = function $$parse(source_buffer) {
        var self = this, $writer = nil, $ret_or_2 = nil;

        return (function() { try {
        
        
        $writer = [source_buffer];
        $send(self.lexer, 'source_buffer=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        self.source_buffer = source_buffer;
        if ($truthy(($ret_or_2 = self.$do_parse()))) {
          return $ret_or_2
        } else {
          return nil
        };
        } finally {
          ((self.source_buffer = nil), (($writer = [nil]), $send(self.lexer, 'source_buffer=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        }; })()
      }, $Base_parse$10.$$arity = 1);
      
      Opal.def(self, '$parse_with_comments', $Base_parse_with_comments$11 = function $$parse_with_comments(source_buffer) {
        var self = this, $writer = nil;

        return (function() { try {
        
        
        $writer = [[]];
        $send(self.lexer, 'comments=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        return [self.$parse(source_buffer), self.lexer.$comments()];
        } finally {
          (($writer = [nil]), $send(self.lexer, 'comments=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)])
        }; })()
      }, $Base_parse_with_comments$11.$$arity = 1);
      
      Opal.def(self, '$tokenize', $Base_tokenize$12 = function $$tokenize(source_buffer, recover) {
        var self = this, $writer = nil, ast = nil;

        
        
        if (recover == null) {
          recover = false;
        };
        return (function() { try {
        
        
        $writer = [[]];
        $send(self.lexer, 'tokens=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [[]];
        $send(self.lexer, 'comments=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        try {
          ast = self.$parse(source_buffer)
        } catch ($err) {
          if (Opal.rescue($err, [$$$($$($nesting, 'Parser'), 'SyntaxError')])) {
            try {
              if ($truthy(recover['$!']())) {
                self.$raise()}
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };;
        return [ast, self.lexer.$comments(), self.lexer.$tokens()];
        } finally {
          ((($writer = [nil]), $send(self.lexer, 'tokens=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]), (($writer = [nil]), $send(self.lexer, 'comments=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]))
        }; })();
      }, $Base_tokenize$12.$$arity = -2);
      self.$private();
      
      Opal.def(self, '$next_token', $Base_next_token$13 = function $$next_token() {
        var self = this, token = nil;

        
        token = self.lexer.$advance();
        self.last_token = token;
        return token;
      }, $Base_next_token$13.$$arity = 0);
      
      Opal.def(self, '$check_kwarg_name', $Base_check_kwarg_name$14 = function $$check_kwarg_name(name_t) {
        var self = this, $case = nil;

        return (function() {$case = name_t['$[]'](0);
        if (/^[a-z_]/['$===']($case)) {return nil}
        else if (/^[A-Z]/['$===']($case)) {return self.$diagnostic("error", "argument_const", nil, name_t)}
        else { return nil }})()
      }, $Base_check_kwarg_name$14.$$arity = 1);
      
      Opal.def(self, '$diagnostic', $Base_diagnostic$15 = function $$diagnostic(level, reason, arguments$, location_t, highlights_ts) {
        var $a, $b, $$16, self = this, _ = nil, location = nil, highlights = nil;

        
        
        if (highlights_ts == null) {
          highlights_ts = [];
        };
        $b = location_t, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        highlights = $send(highlights_ts, 'map', [], ($$16 = function(token){var self = $$16.$$s == null ? this : $$16.$$s, $c, $d, range = nil;

        
          
          if (token == null) {
            token = nil;
          };
          $d = token, $c = Opal.to_ary($d), (_ = ($c[0] == null ? nil : $c[0])), (range = ($c[1] == null ? nil : $c[1])), $d;
          return range;}, $$16.$$s = self, $$16.$$arity = 1, $$16));
        self.diagnostics.$process($$($nesting, 'Diagnostic').$new(level, reason, arguments$, location, highlights));
        if (level['$==']("error")) {
          return self.$yyerror()
        } else {
          return nil
        };
      }, $Base_diagnostic$15.$$arity = -5);
      return (Opal.def(self, '$on_error', $Base_on_error$17 = function $$on_error(error_token_id, error_value, value_stack) {
        var $a, $b, self = this, token_name = nil, _ = nil, location = nil;

        
        token_name = self.$token_to_str(error_token_id);
        $b = error_value, $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (location = ($a[1] == null ? nil : $a[1])), $b;
        return self.diagnostics.$process($$($nesting, 'Diagnostic').$new("error", "unexpected_token", $hash2(["token"], {"token": token_name}), location));
      }, $Base_on_error$17.$$arity = 3), nil) && 'on_error';
    })($nesting[0], $$$($$($nesting, 'Racc'), 'Parser'), $nesting)
  })($nesting[0], $nesting)
})(Opal);
