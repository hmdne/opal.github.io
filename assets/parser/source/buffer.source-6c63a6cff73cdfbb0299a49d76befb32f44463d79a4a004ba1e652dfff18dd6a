/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $enc = Opal.enc, $truthy = Opal.truthy, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$attr_reader', '$empty?', '$=~', '$start_with?', '$freeze', '$==', '$[]', '$nil?', '$!=', '$match', '$find', '$encoding', '$recognize_encoding', '$force_encoding', '$encode', '$to_s', '$source=', '$-', '$open', '$read', '$raise', '$frozen?', '$dup', '$reencode_string', '$class', '$valid_encoding?', '$name', '$raw_source=', '$gsub', '$!', '$ascii_only?', '$line_index_for_position', '$line_begins', '$+', '$to_a', '$lines', '$end_with?', '$<<', '$each', '$chomp!', '$fetch', '$source_lines', '$<', '$>=', '$size', '$new', '$source', '$source_range', '$private', '$index', '$bsearch', '$[]=', '$method_defined?', '$bsearch_index']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Buffer');

        var $nesting = [self].concat($parent_nesting), $Buffer_recognize_encoding$1, $Buffer_reencode_string$2, $Buffer_initialize$3, $Buffer_read$4, $Buffer_source$6, $Buffer_source$eq$7, $Buffer_raw_source$eq$8, $Buffer_slice$9, $Buffer_decompose_position$10, $Buffer_line_for_position$11, $Buffer_column_for_position$12, $Buffer_source_lines$13, $Buffer_source_line$15, $Buffer_line_range$16, $Buffer_source_range$17, $Buffer_last_line$18, $Buffer_freeze$19, $Buffer_line_begins$20, $Buffer_line_index_for_position$21, $Buffer_bsearch$22, $Buffer_bsearch$24;

        self.$$prototype.name = self.$$prototype.source = self.$$prototype.slice_source = self.$$prototype.first_line = self.$$prototype.lines = self.$$prototype.source_range = self.$$prototype.line_begins = self.$$prototype.line_index_for_position = self.$$prototype.line_range = nil;
        
        self.$attr_reader("name", "first_line");
        Opal.const_set($nesting[0], 'ENCODING_RE', Opal.regexp([$enc("[\\s#](en)?coding\\s*[:=]\\s*", "ASCII-8BIT"), $enc("(", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("(utf8-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+?)(-unix|-dos|-mac)", "ASCII-8BIT"), $enc("|", "ASCII-8BIT"), $enc("([A-Za-z0-9_-]+)", "ASCII-8BIT"), $enc(")", "ASCII-8BIT"), $enc("", "ASCII-8BIT")]));
        Opal.defs(self, '$recognize_encoding', $Buffer_recognize_encoding$1 = function $$recognize_encoding(string) {
          var $a, $b, self = this, first_line = nil, second_line = nil, encoding_line = nil, $ret_or_1 = nil, result = nil, $ret_or_2 = nil, $ret_or_3 = nil;

          
          if ($truthy(string['$empty?']())) {
            return nil};
          string['$=~'](/^(.*)\n?(.*\n)?/);
          $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (first_line = $a[0]), (second_line = $a[1]), $a;
          if ($truthy(first_line['$start_with?']($enc("\xEF\xBB\xBF", "ASCII-8BIT").$freeze()))) {
            return $$$($$($nesting, 'Encoding'), 'UTF_8')
          } else if (first_line['$[]'](0, 2)['$==']($enc("#!", "ASCII-8BIT").$freeze())) {
            encoding_line = second_line
          } else {
            encoding_line = first_line
          };
          if ($truthy((function() {if ($truthy(($ret_or_1 = encoding_line['$nil?']()))) {
            return $ret_or_1
          } else {
            return encoding_line['$[]'](0)['$!=']($enc("#", "ASCII-8BIT"))
          }; return nil; })())) {
            return nil};
          if ($truthy((result = $$($nesting, 'ENCODING_RE').$match(encoding_line)))) {
            return $$($nesting, 'Encoding').$find((function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = result['$[]'](3)))) {
              return $ret_or_3
            } else {
              return result['$[]'](4)
            }; return nil; })()))) {
              return $ret_or_2
            } else {
              return result['$[]'](6)
            }; return nil; })())
          } else {
            return nil
          };
        }, $Buffer_recognize_encoding$1.$$arity = 1);
        Opal.defs(self, '$reencode_string', $Buffer_reencode_string$2 = function $$reencode_string(input) {
          var self = this, original_encoding = nil, detected_encoding = nil;

          
          original_encoding = input.$encoding();
          detected_encoding = self.$recognize_encoding(input.$force_encoding($$$($$($nesting, 'Encoding'), 'BINARY')));
          if ($truthy(detected_encoding['$nil?']())) {
            return input.$force_encoding(original_encoding)
          } else if (detected_encoding['$==']($$$($$($nesting, 'Encoding'), 'BINARY'))) {
            return input
          } else {
            return input.$force_encoding(detected_encoding).$encode($$$($$($nesting, 'Encoding'), 'UTF_8'))
          };
        }, $Buffer_reencode_string$2.$$arity = 1);
        
        Opal.def(self, '$initialize', $Buffer_initialize$3 = function $$initialize(name, $a, $b) {
          var $post_args, $kwargs, first_line, source, self = this, $writer = nil;

          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          $kwargs = Opal.extract_kwargs($post_args);
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          if ($post_args.length > 0) {
            first_line = $post_args[0];
            $post_args.splice(0, 1);
          }
          if (first_line == null) {
            first_line = 1;
          };
          
          source = $kwargs.$$smap["source"];
          if (source == null) {
            source = nil
          };
          self.name = name.$to_s();
          self.source = nil;
          self.first_line = first_line;
          self.lines = nil;
          self.line_begins = nil;
          self.slice_source = nil;
          self.line_index_for_position = $hash2([], {});
          if ($truthy(source)) {
            
            $writer = [source];
            $send(self, 'source=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          } else {
            return nil
          };
        }, $Buffer_initialize$3.$$arity = -2);
        
        Opal.def(self, '$read', $Buffer_read$4 = function $$read() {
          var $$5, self = this;

          
          $send($$($nesting, 'File'), 'open', [self.name, $enc("rb", "ASCII-8BIT")], ($$5 = function(io){var self = $$5.$$s == null ? this : $$5.$$s, $writer = nil;

          
            
            if (io == null) {
              io = nil;
            };
            $writer = [io.$read()];
            $send(self, 'source=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];}, $$5.$$s = self, $$5.$$arity = 1, $$5));
          return self;
        }, $Buffer_read$4.$$arity = 0);
        
        Opal.def(self, '$source', $Buffer_source$6 = function $$source() {
          var self = this;

          
          if ($truthy(self.source['$nil?']())) {
            self.$raise($$($nesting, 'RuntimeError'), $enc("Cannot extract source from uninitialized Source::Buffer", "ASCII-8BIT"))};
          return self.source;
        }, $Buffer_source$6.$$arity = 0);
        
        Opal.def(self, '$source=', $Buffer_source$eq$7 = function(input) {
          var self = this, $writer = nil;

          
          if ($truthy(input['$frozen?']())) {
            input = input.$dup()};
          input = self.$class().$reencode_string(input);
          if ($truthy(input['$valid_encoding?']())) {
          } else {
            self.$raise($$($nesting, 'EncodingError'), "" + "invalid byte sequence in " + (input.$encoding().$name()))
          };
          
          $writer = [input];
          $send(self, 'raw_source=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];;
        }, $Buffer_source$eq$7.$$arity = 1);
        
        Opal.def(self, '$raw_source=', $Buffer_raw_source$eq$8 = function(input) {
          var self = this, $ret_or_4 = nil, $ret_or_5 = nil;

          
          if ($truthy(self.source)) {
            self.$raise($$($nesting, 'ArgumentError'), $enc("Source::Buffer is immutable", "ASCII-8BIT"))};
          self.source = input.$gsub($enc("\r\n", "ASCII-8BIT").$freeze(), $enc("\n", "ASCII-8BIT").$freeze()).$freeze();
          if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.source['$ascii_only?']()['$!']()))) {
            return self.source.$encoding()['$!=']($$$($$($nesting, 'Encoding'), 'UTF_32LE'))
          } else {
            return $ret_or_5
          }; return nil; })()))) {
            return self.source.$encoding()['$!=']($$$($$($nesting, 'Encoding'), 'BINARY'))
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return (self.slice_source = self.source.$encode($$$($$($nesting, 'Encoding'), 'UTF_32LE')))
          } else {
            return nil
          };
        }, $Buffer_raw_source$eq$8.$$arity = 1);
        
        Opal.def(self, '$slice', $Buffer_slice$9 = function $$slice(range) {
          var self = this;

          if ($truthy(self.slice_source['$nil?']())) {
            return self.source['$[]'](range)
          } else {
            return self.slice_source['$[]'](range).$encode(self.source.$encoding())
          }
        }, $Buffer_slice$9.$$arity = 1);
        
        Opal.def(self, '$decompose_position', $Buffer_decompose_position$10 = function $$decompose_position(position) {
          var self = this, line_index = nil, line_begin = nil;

          
          line_index = self.$line_index_for_position(position);
          line_begin = self.$line_begins()['$[]'](line_index);
          return [$rb_plus(self.first_line, line_index), $rb_minus(position, line_begin)];
        }, $Buffer_decompose_position$10.$$arity = 1);
        
        Opal.def(self, '$line_for_position', $Buffer_line_for_position$11 = function $$line_for_position(position) {
          var self = this;

          return $rb_plus(self.$line_index_for_position(position), self.first_line)
        }, $Buffer_line_for_position$11.$$arity = 1);
        
        Opal.def(self, '$column_for_position', $Buffer_column_for_position$12 = function $$column_for_position(position) {
          var self = this, line_index = nil;

          
          line_index = self.$line_index_for_position(position);
          return $rb_minus(position, self.$line_begins()['$[]'](line_index));
        }, $Buffer_column_for_position$12.$$arity = 1);
        
        Opal.def(self, '$source_lines', $Buffer_source_lines$13 = function $$source_lines() {
          var $$14, self = this, $ret_or_6 = nil, lines = nil;

          return (self.lines = (function() {if ($truthy(($ret_or_6 = self.lines))) {
            return $ret_or_6
          } else {
            
            lines = self.source.$lines().$to_a();
            if ($truthy(self.source['$end_with?']($enc("\n", "ASCII-8BIT").$freeze()))) {
              lines['$<<']($enc("", "ASCII-8BIT").$dup())};
            $send(lines, 'each', [], ($$14 = function(line){var self = $$14.$$s == null ? this : $$14.$$s;

            
              
              if (line == null) {
                line = nil;
              };
              line['$chomp!']($enc("\n", "ASCII-8BIT").$freeze());
              return line.$freeze();}, $$14.$$s = self, $$14.$$arity = 1, $$14));
            return lines.$freeze();
          }; return nil; })())
        }, $Buffer_source_lines$13.$$arity = 0);
        
        Opal.def(self, '$source_line', $Buffer_source_line$15 = function $$source_line(lineno) {
          var self = this;

          return self.$source_lines().$fetch($rb_minus(lineno, self.first_line)).$dup()
        }, $Buffer_source_line$15.$$arity = 1);
        
        Opal.def(self, '$line_range', $Buffer_line_range$16 = function $$line_range(lineno) {
          var self = this, index = nil, $ret_or_7 = nil;

          
          index = $rb_minus(lineno, self.first_line);
          if ($truthy((function() {if ($truthy(($ret_or_7 = $rb_lt(index, 0)))) {
            return $ret_or_7
          } else {
            return $rb_ge($rb_plus(index, 1), self.$line_begins().$size())
          }; return nil; })())) {
            return self.$raise($$($nesting, 'IndexError'), "" + "Parser::Source::Buffer: range for line " + ("" + (lineno) + " requested, valid line numbers are " + (self.first_line) + "..") + ("" + ($rb_minus($rb_plus(self.first_line, self.$line_begins().$size()), 2))))
          } else {
            return $$($nesting, 'Range').$new(self, self.$line_begins()['$[]'](index), $rb_minus(self.$line_begins()['$[]']($rb_plus(index, 1)), 1))
          };
        }, $Buffer_line_range$16.$$arity = 1);
        
        Opal.def(self, '$source_range', $Buffer_source_range$17 = function $$source_range() {
          var self = this, $ret_or_8 = nil;

          return (self.source_range = (function() {if ($truthy(($ret_or_8 = self.source_range))) {
            return $ret_or_8
          } else {
            return $$($nesting, 'Range').$new(self, 0, self.$source().$size())
          }; return nil; })())
        }, $Buffer_source_range$17.$$arity = 0);
        
        Opal.def(self, '$last_line', $Buffer_last_line$18 = function $$last_line() {
          var self = this;

          return $rb_minus($rb_plus(self.$line_begins().$size(), self.first_line), 2)
        }, $Buffer_last_line$18.$$arity = 0);
        
        Opal.def(self, '$freeze', $Buffer_freeze$19 = function $$freeze() {
          var $iter = $Buffer_freeze$19.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $Buffer_freeze$19.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          self.$source_lines();
          self.$line_begins();
          self.$source_range();
          return $send2(self, Opal.find_super_dispatcher(self, 'freeze', $Buffer_freeze$19, false, true), 'freeze', $zuper, $iter);
        }, $Buffer_freeze$19.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$line_begins', $Buffer_line_begins$20 = function $$line_begins() {
          var $a, self = this, $ret_or_9 = nil, begins = nil, index = nil;

          return (self.line_begins = (function() {if ($truthy(($ret_or_9 = self.line_begins))) {
            return $ret_or_9
          } else {
            
            begins = [0];
            index = 0;
            while ($truthy((index = self.source.$index($enc("\n", "ASCII-8BIT").$freeze(), index)))) {
              
              index = $rb_plus(index, 1);
              begins['$<<'](index);
            };
            begins['$<<']($rb_plus(self.source.$size(), 1));
            return begins;
          }; return nil; })())
        }, $Buffer_line_begins$20.$$arity = 0);
        
        Opal.def(self, '$line_index_for_position', $Buffer_line_index_for_position$21 = function $$line_index_for_position(position) {
          var self = this, $ret_or_10 = nil, index = nil, $writer = nil;

          if ($truthy(($ret_or_10 = self.line_index_for_position['$[]'](position)))) {
            return $ret_or_10
          } else {
            
            index = $rb_minus(self.$bsearch(self.$line_begins(), position), 1);
            if ($truthy(self.line_index_for_position['$frozen?']())) {
            } else {
              
              $writer = [position, index];
              $send(self.line_index_for_position, '[]=', Opal.to_a($writer));
              $writer[$rb_minus($writer["length"], 1)];
            };
            return index;
          }
        }, $Buffer_line_index_for_position$21.$$arity = 1);
        if ($truthy($$($nesting, 'Array')['$method_defined?']("bsearch_index"))) {
          return (Opal.def(self, '$bsearch', $Buffer_bsearch$22 = function $$bsearch(line_begins, position) {
            var $$23, self = this, $ret_or_11 = nil;

            if ($truthy(($ret_or_11 = $send(line_begins, 'bsearch_index', [], ($$23 = function(line_begin){var self = $$23.$$s == null ? this : $$23.$$s;

            
              
              if (line_begin == null) {
                line_begin = nil;
              };
              return $rb_lt(position, line_begin);}, $$23.$$s = self, $$23.$$arity = 1, $$23))))) {
              return $ret_or_11
            } else {
              return $rb_minus(line_begins.$size(), 1)
            }
          }, $Buffer_bsearch$22.$$arity = 2), nil) && 'bsearch'
        } else {
          return (Opal.def(self, '$bsearch', $Buffer_bsearch$24 = function $$bsearch(line_begins, position) {
            var $$25, self = this, $ret_or_12 = nil, $ret_or_13 = nil;

            
            self.line_range = (function() {if ($truthy(($ret_or_12 = self.line_range))) {
              return $ret_or_12
            } else {
              return Opal.Range.$new(0,line_begins.$size(), true)
            }; return nil; })();
            if ($truthy(($ret_or_13 = $send(self.line_range, 'bsearch', [], ($$25 = function(i){var self = $$25.$$s == null ? this : $$25.$$s;

            
              
              if (i == null) {
                i = nil;
              };
              return $rb_lt(position, line_begins['$[]'](i));}, $$25.$$s = self, $$25.$$arity = 1, $$25))))) {
              return $ret_or_13
            } else {
              return $rb_minus(line_begins.$size(), 1)
            };
          }, $Buffer_bsearch$24.$$arity = 2), nil) && 'bsearch'
        };
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
