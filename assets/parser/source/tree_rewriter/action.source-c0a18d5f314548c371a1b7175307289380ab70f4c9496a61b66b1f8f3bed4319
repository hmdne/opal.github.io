/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$freeze', '$empty?', '$do_combine', '$==', '$<<', '$begin', '$concat', '$flat_map', '$to_proc', '$end', '$!', '$insert_before', '$insert_after', '$replacement', '$raise', '$insertion?', '$with', '$begin_pos', '$range', '$first', '$children', '$end_pos', '$last', '$new', '$+', '$map', '$moved', '$protected', '$swallow', '$class', '$merge', '$place_in_hierarchy', '$analyse_hierarchy', '$[]', '$fuse_deletions', '$combine_children', '$inject', '$size', '$bsearch', '$bsearch_child_index', '$>', '$-', '$>=', '$===', '$<=>', '$<=', '$check_fusible', '$<', '$shift', '$pop', '$compact!', '$each', '$call', '$call_enforcer_for_merge', '$!=', '$select']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Action');

        var $nesting = [self].concat($parent_nesting), $Action_initialize$1, $Action_combine$2, $Action_empty$ques$3, $Action_ordered_replacements$4, $Action_nested_actions$5, $Action_insertion$ques$6, $Action_contract$7, $Action_moved$8, $Action_with$10, $Action_do_combine$11, $Action_place_in_hierarchy$12, $Action_combine_children$13, $Action_fuse_deletions$15, $Action_bsearch_child_index$16, $Action_analyse_hierarchy$18, $Action_check_fusible$21, $Action_merge$24, $Action_call_enforcer_for_merge$25, $Action_swallow$27;

        self.$$prototype.insert_before = self.$$prototype.insert_after = self.$$prototype.children = self.$$prototype.replacement = self.$$prototype.range = self.$$prototype.enforcer = nil;
        
        self.$attr_reader("range", "replacement", "insert_before", "insert_after");
        
        Opal.def(self, '$initialize', $Action_initialize$1 = function $$initialize(range, enforcer, $kwargs) {
          var insert_before, replacement, insert_after, children, $a, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          insert_before = $kwargs.$$smap["insert_before"];
          if (insert_before == null) {
            insert_before = ""
          };
          
          replacement = $kwargs.$$smap["replacement"];
          if (replacement == null) {
            replacement = nil
          };
          
          insert_after = $kwargs.$$smap["insert_after"];
          if (insert_after == null) {
            insert_after = ""
          };
          
          children = $kwargs.$$smap["children"];
          if (children == null) {
            children = []
          };
          $a = [range, enforcer, children.$freeze(), insert_before.$freeze(), replacement, insert_after.$freeze()], (self.range = $a[0]), (self.enforcer = $a[1]), (self.children = $a[2]), (self.insert_before = $a[3]), (self.replacement = $a[4]), (self.insert_after = $a[5]), $a;
          return self.$freeze();
        }, $Action_initialize$1.$$arity = -3);
        
        Opal.def(self, '$combine', $Action_combine$2 = function $$combine(action) {
          var self = this;

          
          if ($truthy(action['$empty?']())) {
            return self};
          return self.$do_combine(action);
        }, $Action_combine$2.$$arity = 1);
        
        Opal.def(self, '$empty?', $Action_empty$ques$3 = function() {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;

          if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = self.insert_before['$empty?']()))) {
            return self.insert_after['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })()))) {
            return self.children['$empty?']()
          } else {
            return $ret_or_2
          }; return nil; })()))) {
            
            if ($truthy(($ret_or_4 = self.replacement['$=='](nil)))) {
              return $ret_or_4
            } else {
              
              if ($truthy(($ret_or_5 = self.replacement['$empty?']()))) {
                return self.range['$empty?']()
              } else {
                return $ret_or_5
              };
            };
          } else {
            return $ret_or_1
          }
        }, $Action_empty$ques$3.$$arity = 0);
        
        Opal.def(self, '$ordered_replacements', $Action_ordered_replacements$4 = function $$ordered_replacements() {
          var self = this, reps = nil;

          
          reps = [];
          if ($truthy(self.insert_before['$empty?']())) {
          } else {
            reps['$<<']([self.range.$begin(), self.insert_before])
          };
          if ($truthy(self.replacement)) {
            reps['$<<']([self.range, self.replacement])};
          reps.$concat($send(self.children, 'flat_map', [], "ordered_replacements".$to_proc()));
          if ($truthy(self.insert_after['$empty?']())) {
          } else {
            reps['$<<']([self.range.$end(), self.insert_after])
          };
          return reps;
        }, $Action_ordered_replacements$4.$$arity = 0);
        
        Opal.def(self, '$nested_actions', $Action_nested_actions$5 = function $$nested_actions() {
          var self = this, actions = nil, $ret_or_6 = nil;

          
          actions = [];
          if ($truthy((function() {if ($truthy(($ret_or_6 = self.insert_before['$empty?']()['$!']()))) {
            return $ret_or_6
          } else {
            return self.insert_after['$empty?']()['$!']()
          }; return nil; })())) {
            actions['$<<'](["wrap", self.range, self.insert_before, self.insert_after])};
          if ($truthy(self.replacement)) {
            actions['$<<'](["replace", self.range, self.replacement])};
          return actions.$concat($send(self.children, 'flat_map', [], "nested_actions".$to_proc()));
        }, $Action_nested_actions$5.$$arity = 0);
        
        Opal.def(self, '$insertion?', $Action_insertion$ques$6 = function() {
          var self = this, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil;

          if ($truthy(($ret_or_7 = (function() {if ($truthy(($ret_or_8 = self.$insert_before()['$empty?']()['$!']()))) {
            return $ret_or_8
          } else {
            return self.$insert_after()['$empty?']()['$!']()
          }; return nil; })()))) {
            return $ret_or_7
          } else {
            
            if ($truthy(($ret_or_9 = self.$replacement()))) {
              return self.$replacement()['$empty?']()['$!']()
            } else {
              return $ret_or_9
            };
          }
        }, $Action_insertion$ques$6.$$arity = 0);
        
        Opal.def(self, '$contract', $Action_contract$7 = function $$contract() {
          var self = this, range = nil;

          
          if ($truthy(self['$empty?']())) {
            self.$raise("Empty actions can not be contracted")};
          if ($truthy(self['$insertion?']())) {
            return self};
          range = self.range.$with($hash2(["begin_pos", "end_pos"], {"begin_pos": self.$children().$first().$range().$begin_pos(), "end_pos": self.$children().$last().$range().$end_pos()}));
          return self.$with($hash2(["range"], {"range": range}));
        }, $Action_contract$7.$$arity = 0);
        
        Opal.def(self, '$moved', $Action_moved$8 = function $$moved(source_buffer, offset) {
          var $$9, self = this, moved_range = nil;

          
          moved_range = $$$($$$($$$('::', 'Parser'), 'Source'), 'Range').$new(source_buffer, $rb_plus(self.range.$begin_pos(), offset), $rb_plus(self.range.$end_pos(), offset));
          return self.$with($hash2(["range", "children"], {"range": moved_range, "children": $send(self.$children(), 'map', [], ($$9 = function(child){var self = $$9.$$s == null ? this : $$9.$$s;

          
            
            if (child == null) {
              child = nil;
            };
            return child.$moved(source_buffer, offset);}, $$9.$$s = self, $$9.$$arity = 1, $$9))}));
        }, $Action_moved$8.$$arity = 2);
        self.$protected();
        self.$attr_reader("children");
        
        Opal.def(self, '$with', $Action_with$10 = function($kwargs) {
          var range, enforcer, children, insert_before, replacement, insert_after, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          range = $kwargs.$$smap["range"];
          if (range == null) {
            range = self.range
          };
          
          enforcer = $kwargs.$$smap["enforcer"];
          if (enforcer == null) {
            enforcer = self.enforcer
          };
          
          children = $kwargs.$$smap["children"];
          if (children == null) {
            children = self.children
          };
          
          insert_before = $kwargs.$$smap["insert_before"];
          if (insert_before == null) {
            insert_before = self.insert_before
          };
          
          replacement = $kwargs.$$smap["replacement"];
          if (replacement == null) {
            replacement = self.replacement
          };
          
          insert_after = $kwargs.$$smap["insert_after"];
          if (insert_after == null) {
            insert_after = self.insert_after
          };
          if ($truthy(replacement)) {
            children = self.$swallow(children)};
          return self.$class().$new(range, enforcer, $hash2(["children", "insert_before", "replacement", "insert_after"], {"children": children, "insert_before": insert_before, "replacement": replacement, "insert_after": insert_after}));
        }, $Action_with$10.$$arity = -1);
        
        Opal.def(self, '$do_combine', $Action_do_combine$11 = function $$do_combine(action) {
          var self = this;

          if (action.$range()['$=='](self.range)) {
            return self.$merge(action)
          } else {
            return self.$place_in_hierarchy(action)
          }
        }, $Action_do_combine$11.$$arity = 1);
        
        Opal.def(self, '$place_in_hierarchy', $Action_place_in_hierarchy$12 = function $$place_in_hierarchy(action) {
          var self = this, family = nil, extra_sibbling = nil;

          
          family = self.$analyse_hierarchy(action);
          if ($truthy(family['$[]']("fusible"))) {
            return self.$fuse_deletions(action, family['$[]']("fusible"), [].concat(Opal.to_a(family['$[]']("sibbling_left"))).concat(Opal.to_a(family['$[]']("child"))).concat(Opal.to_a(family['$[]']("sibbling_right"))))
          } else {
            
            extra_sibbling = (function() {if ($truthy(family['$[]']("parent"))) {
              return family['$[]']("parent").$do_combine(action)
            } else if ($truthy(family['$[]']("child"))) {
              return action.$with($hash2(["children", "enforcer"], {"children": family['$[]']("child"), "enforcer": self.enforcer})).$combine_children(action.$children())
            } else {
              return action
            }; return nil; })();
            return self.$with($hash2(["children"], {"children": [].concat(Opal.to_a(family['$[]']("sibbling_left"))).concat([extra_sibbling]).concat(Opal.to_a(family['$[]']("sibbling_right")))}));
          };
        }, $Action_place_in_hierarchy$12.$$arity = 1);
        
        Opal.def(self, '$combine_children', $Action_combine_children$13 = function $$combine_children(more_children) {
          var $$14, self = this;

          return $send(more_children, 'inject', [self], ($$14 = function(parent, new_child){var self = $$14.$$s == null ? this : $$14.$$s;

          
            
            if (parent == null) {
              parent = nil;
            };
            
            if (new_child == null) {
              new_child = nil;
            };
            return parent.$place_in_hierarchy(new_child);}, $$14.$$s = self, $$14.$$arity = 2, $$14))
        }, $Action_combine_children$13.$$arity = 1);
        
        Opal.def(self, '$fuse_deletions', $Action_fuse_deletions$15 = function $$fuse_deletions(action, fusible, other_sibblings) {
          var self = this, without_fusible = nil, fused_range = nil, fused_deletion = nil;

          
          without_fusible = self.$with($hash2(["children"], {"children": other_sibblings}));
          fused_range = $send([action].concat(Opal.to_a(fusible)), 'map', [], "range".$to_proc()).$inject("join");
          fused_deletion = action.$with($hash2(["range"], {"range": fused_range}));
          return without_fusible.$do_combine(fused_deletion);
        }, $Action_fuse_deletions$15.$$arity = 3);
        
        Opal.def(self, '$bsearch_child_index', $Action_bsearch_child_index$16 = function $$bsearch_child_index(from) {
          var $$17, $iter = $Action_bsearch_child_index$16.$$p, $yield = $iter || nil, self = this, size = nil, $ret_or_10 = nil;

          if ($iter) $Action_bsearch_child_index$16.$$p = null;
          
          
          if (from == null) {
            from = 0;
          };
          size = self.children.$size();
          if ($truthy(($ret_or_10 = $send(Opal.Range.$new(from,size, true), 'bsearch', [], ($$17 = function(i){var self = $$17.$$s == null ? this : $$17.$$s;
            if (self.children == null) self.children = nil;

          
            
            if (i == null) {
              i = nil;
            };
            return Opal.yield1($yield, self.children['$[]'](i));;}, $$17.$$s = self, $$17.$$arity = 1, $$17))))) {
            return $ret_or_10
          } else {
            return size
          };
        }, $Action_bsearch_child_index$16.$$arity = -1);
        
        Opal.def(self, '$analyse_hierarchy', $Action_analyse_hierarchy$18 = function $$analyse_hierarchy(action) {
          var $$19, $$20, self = this, r = nil, left_index = nil, start = nil, right_index = nil, center = nil, $case = nil, parent = nil, overlap_left = nil, overlap_right = nil, $ret_or_11 = nil, $ret_or_12 = nil, contained = nil, fusible = nil;

          
          r = action.$range();
          left_index = $send(self, 'bsearch_child_index', [], ($$19 = function(child){var self = $$19.$$s == null ? this : $$19.$$s;

          
            
            if (child == null) {
              child = nil;
            };
            return $rb_gt(child.$range().$end_pos(), r.$begin_pos());}, $$19.$$s = self, $$19.$$arity = 1, $$19));
          start = (function() {if (left_index['$=='](0)) {
            return 0
          } else {
            return $rb_minus(left_index, 1)
          }; return nil; })();
          right_index = $send(self, 'bsearch_child_index', [start], ($$20 = function(child){var self = $$20.$$s == null ? this : $$20.$$s;

          
            
            if (child == null) {
              child = nil;
            };
            return $rb_ge(child.$range().$begin_pos(), r.$end_pos());}, $$20.$$s = self, $$20.$$arity = 1, $$20));
          center = $rb_minus(right_index, left_index);
          $case = center;
          if ((0)['$===']($case)) {nil}
          else if ((-1)['$===']($case)) {
          left_index = $rb_minus(left_index, 1);
          right_index = $rb_plus(right_index, 1);
          parent = self.children['$[]'](left_index);}
          else {
          overlap_left = self.children['$[]'](left_index).$range().$begin_pos()['$<=>'](r.$begin_pos());
          overlap_right = self.children['$[]']($rb_minus(right_index, 1)).$range().$end_pos()['$<=>'](r.$end_pos());
          if ($truthy((function() {if ($truthy(($ret_or_11 = (function() {if ($truthy(($ret_or_12 = center['$=='](1)))) {
            return $rb_le(overlap_left, 0)
          } else {
            return $ret_or_12
          }; return nil; })()))) {
            return $rb_ge(overlap_right, 0)
          } else {
            return $ret_or_11
          }; return nil; })())) {
            parent = self.children['$[]'](left_index)
          } else {
            
            contained = self.children['$[]'](Opal.Range.$new(left_index,right_index, true));
            fusible = self.$check_fusible(action, (function() {if ($truthy($rb_lt(overlap_left, 0))) {
              return contained.$shift()
            } else {
              return nil
            }; return nil; })(), (function() {if ($truthy($rb_gt(overlap_right, 0))) {
              return contained.$pop()
            } else {
              return nil
            }; return nil; })());
          };};
          return $hash2(["parent", "sibbling_left", "sibbling_right", "fusible", "child"], {"parent": parent, "sibbling_left": self.children['$[]'](Opal.Range.$new(0,left_index, true)), "sibbling_right": self.children['$[]'](Opal.Range.$new(right_index,self.children.$size(), true)), "fusible": fusible, "child": contained});
        }, $Action_analyse_hierarchy$18.$$arity = 1);
        
        Opal.def(self, '$check_fusible', $Action_check_fusible$21 = function $$check_fusible(action, $a) {
          var $post_args, fusible, $$22, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          fusible = $post_args;;
          fusible['$compact!']();
          if ($truthy(fusible['$empty?']())) {
            return nil};
          $send(fusible, 'each', [], ($$22 = function(child){var self = $$22.$$s == null ? this : $$22.$$s, $$23, kind = nil, $ret_or_13 = nil;
            if (self.enforcer == null) self.enforcer = nil;

          
            
            if (child == null) {
              child = nil;
            };
            kind = (function() {if ($truthy((function() {if ($truthy(($ret_or_13 = action['$insertion?']()))) {
              return $ret_or_13
            } else {
              return child['$insertion?']()
            }; return nil; })())) {
              return "crossing_insertions"
            } else {
              return "crossing_deletions"
            }; return nil; })();
            return $send(self.enforcer, 'call', [kind], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

            return $hash2(["range", "conflict"], {"range": action.$range(), "conflict": child.$range()})}, $$23.$$s = self, $$23.$$arity = 0, $$23));}, $$22.$$s = self, $$22.$$arity = 1, $$22));
          return fusible;
        }, $Action_check_fusible$21.$$arity = -2);
        
        Opal.def(self, '$merge', $Action_merge$24 = function $$merge(action) {
          var self = this, $ret_or_14 = nil;

          
          self.$call_enforcer_for_merge(action);
          return self.$with($hash2(["insert_before", "replacement", "insert_after"], {"insert_before": "" + (action.$insert_before()) + (self.$insert_before()), "replacement": (function() {if ($truthy(($ret_or_14 = action.$replacement()))) {
            return $ret_or_14
          } else {
            return self.replacement
          }; return nil; })(), "insert_after": "" + (self.$insert_after()) + (action.$insert_after())})).$combine_children(action.$children());
        }, $Action_merge$24.$$arity = 1);
        
        Opal.def(self, '$call_enforcer_for_merge', $Action_call_enforcer_for_merge$25 = function $$call_enforcer_for_merge(action) {
          var $$26, self = this;

          return $send(self.enforcer, 'call', ["different_replacements"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s, $ret_or_15 = nil, $ret_or_16 = nil;
            if (self.replacement == null) self.replacement = nil;
            if (self.range == null) self.range = nil;

          if ($truthy((function() {if ($truthy(($ret_or_15 = (function() {if ($truthy(($ret_or_16 = self.replacement))) {
              return action.$replacement()
            } else {
              return $ret_or_16
            }; return nil; })()))) {
              return self.replacement['$!='](action.$replacement())
            } else {
              return $ret_or_15
            }; return nil; })())) {
              return $hash2(["range", "replacement", "other_replacement"], {"range": self.range, "replacement": action.$replacement(), "other_replacement": self.replacement})
            } else {
              return nil
            }}, $$26.$$s = self, $$26.$$arity = 0, $$26))
        }, $Action_call_enforcer_for_merge$25.$$arity = 1);
        return (Opal.def(self, '$swallow', $Action_swallow$27 = function $$swallow(children) {
          var $$28, self = this;

          
          $send(self.enforcer, 'call', ["swallowed_insertions"], ($$28 = function(){var self = $$28.$$s == null ? this : $$28.$$s, insertions = nil;
            if (self.range == null) self.range = nil;

          
            insertions = $send(children, 'select', [], "insertion?".$to_proc());
            if ($truthy(insertions['$empty?']())) {
              return nil
            } else {
              return $hash2(["range", "conflict"], {"range": self.range, "conflict": $send(insertions, 'map', [], "range".$to_proc())})
            };}, $$28.$$s = self, $$28.$$arity = 0, $$28));
          return [];
        }, $Action_swallow$27.$$arity = 1), nil) && 'swallow';
      })($$($nesting, 'TreeRewriter'), null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
