/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2;

  Opal.add_stubs(['$include', '$attr_reader', '$<', '$raise', '$nil?', '$freeze', '$with', '$-', '$line_for_position', '$alias_method', '$column_for_position', '$!=', '$line', '$last_line', '$inspect', '$column', '$last_column', '$source_line', '$slice', '$begin_pos', '$end_pos', '$include?', '$source', '$to_a', '$decompose_position', '$join', '$name', '$+', '$new', '$min', '$max', '$disjoint?', '$empty?', '$>=', '$!', '$<=>', '$contains?', '$overlaps?', '$==', '$*', '$is_a?', '$source_buffer', '$nonzero?', '$hash']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Range');

        var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_begin$2, $Range_end$3, $Range_size$4, $Range_line$5, $Range_column$6, $Range_last_line$7, $Range_last_column$8, $Range_column_range$9, $Range_source_line$10, $Range_source$11, $Range_is$ques$12, $Range_to_a$13, $Range_to_range$14, $Range_to_s$15, $Range_with$16, $Range_adjust$17, $Range_resize$18, $Range_join$19, $Range_intersect$20, $Range_disjoint$ques$21, $Range_overlaps$ques$22, $Range_contains$ques$23, $Range_contained$ques$24, $Range_crossing$ques$25, $Range_empty$ques$26, $Range_$lt_eq_gt$27, $Range_hash$28, $Range_inspect$29;

        self.$$prototype.begin_pos = self.$$prototype.end_pos = self.$$prototype.source_buffer = nil;
        
        self.$include($$($nesting, 'Comparable'));
        self.$attr_reader("source_buffer");
        self.$attr_reader("begin_pos", "end_pos");
        
        Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(source_buffer, begin_pos, end_pos) {
          var $a, self = this;

          
          if ($truthy($rb_lt(end_pos, begin_pos))) {
            self.$raise($$($nesting, 'ArgumentError'), "Parser::Source::Range: end_pos must not be less than begin_pos")};
          if ($truthy(source_buffer['$nil?']())) {
            self.$raise($$($nesting, 'ArgumentError'), "Parser::Source::Range: source_buffer must not be nil")};
          self.source_buffer = source_buffer;
          $a = [begin_pos, end_pos], (self.begin_pos = $a[0]), (self.end_pos = $a[1]), $a;
          return self.$freeze();
        }, $Range_initialize$1.$$arity = 3);
        
        Opal.def(self, '$begin', $Range_begin$2 = function $$begin() {
          var self = this;

          return self.$with($hash2(["end_pos"], {"end_pos": self.begin_pos}))
        }, $Range_begin$2.$$arity = 0);
        
        Opal.def(self, '$end', $Range_end$3 = function $$end() {
          var self = this;

          return self.$with($hash2(["begin_pos"], {"begin_pos": self.end_pos}))
        }, $Range_end$3.$$arity = 0);
        
        Opal.def(self, '$size', $Range_size$4 = function $$size() {
          var self = this;

          return $rb_minus(self.end_pos, self.begin_pos)
        }, $Range_size$4.$$arity = 0);
        Opal.alias(self, "length", "size");
        
        Opal.def(self, '$line', $Range_line$5 = function $$line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.begin_pos)
        }, $Range_line$5.$$arity = 0);
        self.$alias_method("first_line", "line");
        
        Opal.def(self, '$column', $Range_column$6 = function $$column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.begin_pos)
        }, $Range_column$6.$$arity = 0);
        
        Opal.def(self, '$last_line', $Range_last_line$7 = function $$last_line() {
          var self = this;

          return self.source_buffer.$line_for_position(self.end_pos)
        }, $Range_last_line$7.$$arity = 0);
        
        Opal.def(self, '$last_column', $Range_last_column$8 = function $$last_column() {
          var self = this;

          return self.source_buffer.$column_for_position(self.end_pos)
        }, $Range_last_column$8.$$arity = 0);
        
        Opal.def(self, '$column_range', $Range_column_range$9 = function $$column_range() {
          var self = this;

          
          if ($truthy(self.$line()['$!='](self.$last_line()))) {
            self.$raise($$($nesting, 'RangeError'), "" + (self.$inspect()) + " spans more than one line")};
          return Opal.Range.$new(self.$column(),self.$last_column(), true);
        }, $Range_column_range$9.$$arity = 0);
        
        Opal.def(self, '$source_line', $Range_source_line$10 = function $$source_line() {
          var self = this;

          return self.source_buffer.$source_line(self.$line())
        }, $Range_source_line$10.$$arity = 0);
        
        Opal.def(self, '$source', $Range_source$11 = function $$source() {
          var self = this;

          return self.source_buffer.$slice(Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true))
        }, $Range_source$11.$$arity = 0);
        
        Opal.def(self, '$is?', $Range_is$ques$12 = function($a) {
          var $post_args, what, self = this;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          what = $post_args;;
          return what['$include?'](self.$source());
        }, $Range_is$ques$12.$$arity = -1);
        
        Opal.def(self, '$to_a', $Range_to_a$13 = function $$to_a() {
          var self = this;

          return Opal.Range.$new(self.begin_pos,self.end_pos, true).$to_a()
        }, $Range_to_a$13.$$arity = 0);
        
        Opal.def(self, '$to_range', $Range_to_range$14 = function $$to_range() {
          var self = this;

          return Opal.Range.$new(self.$begin_pos(),self.$end_pos(), true)
        }, $Range_to_range$14.$$arity = 0);
        
        Opal.def(self, '$to_s', $Range_to_s$15 = function $$to_s() {
          var $a, $b, self = this, line = nil, column = nil;

          
          $b = self.source_buffer.$decompose_position(self.begin_pos), $a = Opal.to_ary($b), (line = ($a[0] == null ? nil : $a[0])), (column = ($a[1] == null ? nil : $a[1])), $b;
          return [self.source_buffer.$name(), line, $rb_plus(column, 1)].$join(":");
        }, $Range_to_s$15.$$arity = 0);
        
        Opal.def(self, '$with', $Range_with$16 = function($kwargs) {
          var begin_pos, end_pos, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          begin_pos = $kwargs.$$smap["begin_pos"];
          if (begin_pos == null) {
            begin_pos = self.begin_pos
          };
          
          end_pos = $kwargs.$$smap["end_pos"];
          if (end_pos == null) {
            end_pos = self.end_pos
          };
          return $$($nesting, 'Range').$new(self.source_buffer, begin_pos, end_pos);
        }, $Range_with$16.$$arity = -1);
        
        Opal.def(self, '$adjust', $Range_adjust$17 = function $$adjust($kwargs) {
          var begin_pos, end_pos, self = this;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          begin_pos = $kwargs.$$smap["begin_pos"];
          if (begin_pos == null) {
            begin_pos = 0
          };
          
          end_pos = $kwargs.$$smap["end_pos"];
          if (end_pos == null) {
            end_pos = 0
          };
          return $$($nesting, 'Range').$new(self.source_buffer, $rb_plus(self.begin_pos, begin_pos), $rb_plus(self.end_pos, end_pos));
        }, $Range_adjust$17.$$arity = -1);
        
        Opal.def(self, '$resize', $Range_resize$18 = function $$resize(new_size) {
          var self = this;

          return self.$with($hash2(["end_pos"], {"end_pos": $rb_plus(self.begin_pos, new_size)}))
        }, $Range_resize$18.$$arity = 1);
        
        Opal.def(self, '$join', $Range_join$19 = function $$join(other) {
          var self = this;

          return $$($nesting, 'Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$min(), [self.end_pos, other.$end_pos()].$max())
        }, $Range_join$19.$$arity = 1);
        
        Opal.def(self, '$intersect', $Range_intersect$20 = function $$intersect(other) {
          var self = this;

          if ($truthy(self['$disjoint?'](other))) {
            return nil
          } else {
            return $$($nesting, 'Range').$new(self.source_buffer, [self.begin_pos, other.$begin_pos()].$max(), [self.end_pos, other.$end_pos()].$min())
          }
        }, $Range_intersect$20.$$arity = 1);
        
        Opal.def(self, '$disjoint?', $Range_disjoint$ques$21 = function(other) {
          var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy((function() {if ($truthy(($ret_or_1 = self['$empty?']()))) {
            return other['$empty?']()
          } else {
            return $ret_or_1
          }; return nil; })())) {
            return self.begin_pos['$!='](other.$begin_pos())
          } else if ($truthy(($ret_or_2 = $rb_ge(self.begin_pos, other.$end_pos())))) {
            return $ret_or_2
          } else {
            return $rb_ge(other.$begin_pos(), self.end_pos)
          }
        }, $Range_disjoint$ques$21.$$arity = 1);
        
        Opal.def(self, '$overlaps?', $Range_overlaps$ques$22 = function(other) {
          var self = this;

          return self['$disjoint?'](other)['$!']()
        }, $Range_overlaps$ques$22.$$arity = 1);
        
        Opal.def(self, '$contains?', $Range_contains$ques$23 = function(other) {
          var self = this;

          return $rb_ge($rb_plus(other.$begin_pos()['$<=>'](self.begin_pos), self.end_pos['$<=>'](other.$end_pos())), (function() {if ($truthy(other['$empty?']())) {
            return 2
          } else {
            return 1
          }; return nil; })())
        }, $Range_contains$ques$23.$$arity = 1);
        
        Opal.def(self, '$contained?', $Range_contained$ques$24 = function(other) {
          var self = this;

          return other['$contains?'](self)
        }, $Range_contained$ques$24.$$arity = 1);
        
        Opal.def(self, '$crossing?', $Range_crossing$ques$25 = function(other) {
          var self = this;

          
          if ($truthy(self['$overlaps?'](other))) {
          } else {
            return false
          };
          return $rb_times(self.begin_pos['$<=>'](other.$begin_pos()), self.end_pos['$<=>'](other.$end_pos()))['$=='](1);
        }, $Range_crossing$ques$25.$$arity = 1);
        
        Opal.def(self, '$empty?', $Range_empty$ques$26 = function() {
          var self = this;

          return self.begin_pos['$=='](self.end_pos)
        }, $Range_empty$ques$26.$$arity = 0);
        
        Opal.def(self, '$<=>', $Range_$lt_eq_gt$27 = function(other) {
          var self = this, $ret_or_3 = nil, $ret_or_4 = nil;

          
          if ($truthy((function() {if ($truthy(($ret_or_3 = other['$is_a?']($$$($$$($$$('::', 'Parser'), 'Source'), 'Range'))))) {
            return self.source_buffer['$=='](other.$source_buffer())
          } else {
            return $ret_or_3
          }; return nil; })())) {
          } else {
            return nil
          };
          if ($truthy(($ret_or_4 = self.begin_pos['$<=>'](other.$begin_pos())['$nonzero?']()))) {
            return $ret_or_4
          } else {
            
            return self.end_pos['$<=>'](other.$end_pos());
          };
        }, $Range_$lt_eq_gt$27.$$arity = 1);
        self.$alias_method("eql?", "==");
        
        Opal.def(self, '$hash', $Range_hash$28 = function $$hash() {
          var self = this;

          return [self.source_buffer, self.begin_pos, self.end_pos].$hash()
        }, $Range_hash$28.$$arity = 0);
        return (Opal.def(self, '$inspect', $Range_inspect$29 = function $$inspect() {
          var self = this;

          return "" + "#<Parser::Source::Range " + (self.source_buffer.$name()) + " " + (self.begin_pos) + "..." + (self.end_pos) + ">"
        }, $Range_inspect$29.$$arity = 0), nil) && 'inspect';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
