/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $lambda = Opal.lambda, $gvars = Opal.gvars, $send = Opal.send, $truthy = Opal.truthy, $hash = Opal.hash, $slice = Opal.slice;

  Opal.add_stubs(['$attr_reader', '$new', '$puts', '$render', '$consumer=', '$-', '$freeze', '$check_policy_validity', '$method', '$adjust', '$source_range', '$empty?', '$==', '$source_buffer', '$raise', '$combine', '$action_root', '$merge!', '$dup', '$contract', '$+', '$begin_pos', '$range', '$end_pos', '$check_range_validity', '$moved', '$to_s', '$replace', '$wrap', '$source', '$each', '$ordered_replacements', '$<<', '$[]', '$length', '$join', '$nested_actions', '$class', '$warn_of_deprecation', '$insert_before', '$insert_after', '$extend', '$protected', '$private', '$values', '$<', '$>', '$size', '$to_range', '$trigger_policy', '$process']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TreeRewriter');

        var $nesting = [self].concat($parent_nesting), $TreeRewriter_initialize$1, $TreeRewriter_empty$ques$3, $TreeRewriter_merge$excl$4, $TreeRewriter_merge$5, $TreeRewriter_import$excl$6, $TreeRewriter_replace$7, $TreeRewriter_wrap$8, $TreeRewriter_remove$9, $TreeRewriter_insert_before$10, $TreeRewriter_insert_after$11, $TreeRewriter_process$12, $TreeRewriter_as_replacements$14, $TreeRewriter_as_nested_actions$15, $TreeRewriter_transaction$16, $TreeRewriter_in_transaction$ques$17, $TreeRewriter_insert_before_multi$18, $TreeRewriter_insert_after_multi$19, $TreeRewriter_check_policy_validity$20, $TreeRewriter_combine$21, $TreeRewriter_check_range_validity$22, $TreeRewriter_enforce_policy$23, $TreeRewriter_trigger_policy$24;

        self.$$prototype.diagnostics = self.$$prototype.source_buffer = self.$$prototype.enforcer = self.$$prototype.action_root = self.$$prototype.in_transaction = self.$$prototype.policy = nil;
        
        self.$attr_reader("source_buffer");
        self.$attr_reader("diagnostics");
        
        Opal.def(self, '$initialize', $TreeRewriter_initialize$1 = function $$initialize(source_buffer, $kwargs) {
          var crossing_deletions, different_replacements, swallowed_insertions, $$2, self = this, $writer = nil, all_encompassing_range = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          crossing_deletions = $kwargs.$$smap["crossing_deletions"];
          if (crossing_deletions == null) {
            crossing_deletions = "accept"
          };
          
          different_replacements = $kwargs.$$smap["different_replacements"];
          if (different_replacements == null) {
            different_replacements = "accept"
          };
          
          swallowed_insertions = $kwargs.$$smap["swallowed_insertions"];
          if (swallowed_insertions == null) {
            swallowed_insertions = "accept"
          };
          self.diagnostics = $$$($$($nesting, 'Diagnostic'), 'Engine').$new();
          
          $writer = [$lambda(($$2 = function(diag){var self = $$2.$$s == null ? this : $$2.$$s;
            if ($gvars.stderr == null) $gvars.stderr = nil;

          
            
            if (diag == null) {
              diag = nil;
            };
            return $gvars.stderr.$puts(diag.$render());}, $$2.$$s = self, $$2.$$arity = 1, $$2))];
          $send(self.diagnostics, 'consumer=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          self.source_buffer = source_buffer;
          self.in_transaction = false;
          self.policy = $hash2(["crossing_deletions", "different_replacements", "swallowed_insertions"], {"crossing_deletions": crossing_deletions, "different_replacements": different_replacements, "swallowed_insertions": swallowed_insertions}).$freeze();
          self.$check_policy_validity();
          self.enforcer = self.$method("enforce_policy");
          all_encompassing_range = self.source_buffer.$source_range().$adjust($hash2(["begin_pos", "end_pos"], {"begin_pos": -1, "end_pos": 1}));
          return (self.action_root = $$$($$($nesting, 'TreeRewriter'), 'Action').$new(all_encompassing_range, self.enforcer));
        }, $TreeRewriter_initialize$1.$$arity = -2);
        
        Opal.def(self, '$empty?', $TreeRewriter_empty$ques$3 = function() {
          var self = this;

          return self.action_root['$empty?']()
        }, $TreeRewriter_empty$ques$3.$$arity = 0);
        
        Opal.def(self, '$merge!', $TreeRewriter_merge$excl$4 = function(with$) {
          var self = this;

          
          if (self.$source_buffer()['$=='](with$.$source_buffer())) {
          } else {
            self.$raise("TreeRewriter are not for the same source_buffer")
          };
          self.action_root = self.action_root.$combine(with$.$action_root());
          return self;
        }, $TreeRewriter_merge$excl$4.$$arity = 1);
        
        Opal.def(self, '$merge', $TreeRewriter_merge$5 = function $$merge(with$) {
          var self = this;

          return self.$dup()['$merge!'](with$)
        }, $TreeRewriter_merge$5.$$arity = 1);
        
        Opal.def(self, '$import!', $TreeRewriter_import$excl$6 = function(foreign_rewriter, $kwargs) {
          var offset, self = this, contracted = nil, merge_effective_range = nil, merge_with = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          offset = $kwargs.$$smap["offset"];
          if (offset == null) {
            offset = 0
          };
          if ($truthy(foreign_rewriter['$empty?']())) {
            return self};
          contracted = foreign_rewriter.$action_root().$contract();
          merge_effective_range = $$$($$$($$$('::', 'Parser'), 'Source'), 'Range').$new(self.source_buffer, $rb_plus(contracted.$range().$begin_pos(), offset), $rb_plus(contracted.$range().$end_pos(), offset));
          self.$check_range_validity(merge_effective_range);
          merge_with = contracted.$moved(self.source_buffer, offset);
          self.action_root = self.action_root.$combine(merge_with);
          return self;
        }, $TreeRewriter_import$excl$6.$$arity = -2);
        
        Opal.def(self, '$replace', $TreeRewriter_replace$7 = function $$replace(range, content) {
          var self = this;

          return self.$combine(range, $hash2(["replacement"], {"replacement": content}))
        }, $TreeRewriter_replace$7.$$arity = 2);
        
        Opal.def(self, '$wrap', $TreeRewriter_wrap$8 = function $$wrap(range, insert_before, insert_after) {
          var self = this;

          return self.$combine(range, $hash2(["insert_before", "insert_after"], {"insert_before": insert_before.$to_s(), "insert_after": insert_after.$to_s()}))
        }, $TreeRewriter_wrap$8.$$arity = 3);
        
        Opal.def(self, '$remove', $TreeRewriter_remove$9 = function $$remove(range) {
          var self = this;

          return self.$replace(range, "".$freeze())
        }, $TreeRewriter_remove$9.$$arity = 1);
        
        Opal.def(self, '$insert_before', $TreeRewriter_insert_before$10 = function $$insert_before(range, content) {
          var self = this;

          return self.$wrap(range, content, nil)
        }, $TreeRewriter_insert_before$10.$$arity = 2);
        
        Opal.def(self, '$insert_after', $TreeRewriter_insert_after$11 = function $$insert_after(range, content) {
          var self = this;

          return self.$wrap(range, nil, content)
        }, $TreeRewriter_insert_after$11.$$arity = 2);
        
        Opal.def(self, '$process', $TreeRewriter_process$12 = function $$process() {
          var $$13, self = this, source = nil, chunks = nil, last_end = nil;

          
          source = self.source_buffer.$source();
          chunks = [];
          last_end = 0;
          $send(self.action_root.$ordered_replacements(), 'each', [], ($$13 = function(range, replacement){var self = $$13.$$s == null ? this : $$13.$$s;

          
            
            if (range == null) {
              range = nil;
            };
            
            if (replacement == null) {
              replacement = nil;
            };
            chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,range.$begin_pos(), true)))['$<<'](replacement);
            return (last_end = range.$end_pos());}, $$13.$$s = self, $$13.$$arity = 2, $$13));
          chunks['$<<'](source['$[]'](Opal.Range.$new(last_end,source.$length(), true)));
          return chunks.$join();
        }, $TreeRewriter_process$12.$$arity = 0);
        
        Opal.def(self, '$as_replacements', $TreeRewriter_as_replacements$14 = function $$as_replacements() {
          var self = this;

          return self.action_root.$ordered_replacements()
        }, $TreeRewriter_as_replacements$14.$$arity = 0);
        
        Opal.def(self, '$as_nested_actions', $TreeRewriter_as_nested_actions$15 = function $$as_nested_actions() {
          var self = this;

          return self.action_root.$nested_actions()
        }, $TreeRewriter_as_nested_actions$15.$$arity = 0);
        
        Opal.def(self, '$transaction', $TreeRewriter_transaction$16 = function $$transaction() {
          var $iter = $TreeRewriter_transaction$16.$$p, $yield = $iter || nil, self = this, previous = nil, restore_root = nil;

          if ($iter) $TreeRewriter_transaction$16.$$p = null;
          return (function() { try {
          
          if (($yield !== nil)) {
          } else {
            self.$raise("" + (self.$class()) + "#" + ("transaction") + " requires block")
          };
          previous = self.in_transaction;
          self.in_transaction = true;
          restore_root = self.action_root;
          Opal.yieldX($yield, []);
          restore_root = nil;
          return self;
          } finally {
            ((function() {if ($truthy(restore_root)) {
              return (self.action_root = restore_root)
            } else {
              return nil
            }; return nil; })(), (self.in_transaction = previous))
          }; })()
        }, $TreeRewriter_transaction$16.$$arity = 0);
        
        Opal.def(self, '$in_transaction?', $TreeRewriter_in_transaction$ques$17 = function() {
          var self = this;

          return self.in_transaction
        }, $TreeRewriter_in_transaction$ques$17.$$arity = 0);
        
        Opal.def(self, '$insert_before_multi', $TreeRewriter_insert_before_multi$18 = function $$insert_before_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_before(range, text);
        }, $TreeRewriter_insert_before_multi$18.$$arity = 2);
        
        Opal.def(self, '$insert_after_multi', $TreeRewriter_insert_after_multi$19 = function $$insert_after_multi(range, text) {
          var self = this;

          
          self.$class().$warn_of_deprecation();
          return self.$insert_after(range, text);
        }, $TreeRewriter_insert_after_multi$19.$$arity = 2);
        Opal.const_set($nesting[0], 'DEPRECATION_WARNING', ["TreeRewriter#insert_before_multi and insert_before_multi exist only for legacy compatibility.", "Please update your code to use `wrap`, `insert_before` or `insert_after` instead."].$join("\n").$freeze());
        self.$extend($$($nesting, 'Deprecation'));
        self.$protected();
        self.$attr_reader("action_root");
        self.$private();
        Opal.const_set($nesting[0], 'ACTIONS', ["accept", "warn", "raise"].$freeze());
        
        Opal.def(self, '$check_policy_validity', $TreeRewriter_check_policy_validity$20 = function $$check_policy_validity() {
          var self = this, invalid = nil;

          
          invalid = $rb_minus(self.policy.$values(), $$($nesting, 'ACTIONS'));
          if ($truthy(invalid['$empty?']())) {
            return nil
          } else {
            return self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid policy: " + (invalid.$join(", ")))
          };
        }, $TreeRewriter_check_policy_validity$20.$$arity = 0);
        
        Opal.def(self, '$combine', $TreeRewriter_combine$21 = function $$combine(range, attributes) {
          var self = this, action = nil;

          
          range = self.$check_range_validity(range);
          action = $$$($$($nesting, 'TreeRewriter'), 'Action').$new(range, self.enforcer, Opal.to_hash(attributes));
          self.action_root = self.action_root.$combine(action);
          return self;
        }, $TreeRewriter_combine$21.$$arity = 2);
        
        Opal.def(self, '$check_range_validity', $TreeRewriter_check_range_validity$22 = function $$check_range_validity(range) {
          var self = this, $ret_or_1 = nil;

          
          if ($truthy((function() {if ($truthy(($ret_or_1 = $rb_lt(range.$begin_pos(), 0)))) {
            return $ret_or_1
          } else {
            return $rb_gt(range.$end_pos(), self.source_buffer.$source().$size())
          }; return nil; })())) {
            self.$raise($$($nesting, 'IndexError'), "" + "The range " + (range.$to_range()) + " is outside the bounds of the source")};
          return range;
        }, $TreeRewriter_check_range_validity$22.$$arity = 1);
        
        Opal.def(self, '$enforce_policy', $TreeRewriter_enforce_policy$23 = function $$enforce_policy(event) {
          var $iter = $TreeRewriter_enforce_policy$23.$$p, $yield = $iter || nil, self = this, values = nil;

          if ($iter) $TreeRewriter_enforce_policy$23.$$p = null;
          
          if (self.policy['$[]'](event)['$==']("accept")) {
            return nil};
          if ($truthy((values = Opal.yieldX($yield, [])))) {
          } else {
            return nil
          };
          return self.$trigger_policy(event, Opal.to_hash(values));
        }, $TreeRewriter_enforce_policy$23.$$arity = 1);
        Opal.const_set($nesting[0], 'POLICY_TO_LEVEL', $hash2(["warn", "raise"], {"warn": "warning", "raise": "error"}).$freeze());
        return (Opal.def(self, '$trigger_policy', $TreeRewriter_trigger_policy$24 = function $$trigger_policy(event, $kwargs) {
          var range, conflict, arguments$, $a, $b, self = this, action = nil, $ret_or_2 = nil, diag = nil, highlights = nil;

          
          
          if ($kwargs == null) {
            $kwargs = $hash2([], {});
          } else if (!$kwargs.$$is_hash) {
            throw Opal.ArgumentError.$new('expected kwargs');
          };
          
          range = $kwargs.$$smap["range"];
          if (range == null) {
            range = self.$raise()
          };
          
          conflict = $kwargs.$$smap["conflict"];
          if (conflict == null) {
            conflict = nil
          };
          
          arguments$ = Opal.kwrestargs($kwargs, {'range': true,'conflict': true});;
          action = (function() {if ($truthy(($ret_or_2 = self.policy['$[]'](event)))) {
            return $ret_or_2
          } else {
            return "raise"
          }; return nil; })();
          diag = $$$($$($nesting, 'Parser'), 'Diagnostic').$new($$($nesting, 'POLICY_TO_LEVEL')['$[]'](action), event, arguments$, range);
          self.diagnostics.$process(diag);
          if ($truthy(conflict)) {
            
            $b = conflict, $a = Opal.to_ary($b), (range = ($a[0] == null ? nil : $a[0])), (highlights = $slice.call($a, 1)), $b;
            diag = $$$($$($nesting, 'Parser'), 'Diagnostic').$new($$($nesting, 'POLICY_TO_LEVEL')['$[]'](action), "" + (event) + "_conflict", arguments$, range, highlights);
            self.diagnostics.$process(diag);};
          if (action['$==']("raise")) {
            return self.$raise($$$($$($nesting, 'Parser'), 'ClobberingError'), "Parser::Source::TreeRewriter detected clobbering")
          } else {
            return nil
          };
        }, $TreeRewriter_trigger_policy$24.$$arity = -2), nil) && 'trigger_policy';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
