/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$attr_reader', '$freeze', '$line', '$alias_method', '$column', '$last_line', '$last_column', '$with', '$update_expression', '$==', '$class', '$reduce', '$map', '$instance_variables', '$instance_variable_get', '$send', '$inject', '$to_sym', '$[]', '$[]=', '$-', '$protected', '$tap', '$dup', '$to_proc']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Parser');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Source');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Map');

        var $nesting = [self].concat($parent_nesting), $Map_initialize$1, $Map_initialize_copy$2, $Map_node$eq$3, $Map_line$4, $Map_column$5, $Map_last_line$6, $Map_last_column$7, $Map_with_expression$8, $Map_$eq_eq$10, $Map_to_hash$12, $Map_with$14, $Map_update_expression$15;

        self.$$prototype.node = self.$$prototype.expression = nil;
        
        self.$attr_reader("node");
        self.$attr_reader("expression");
        
        Opal.def(self, '$initialize', $Map_initialize$1 = function $$initialize(expression) {
          var self = this;

          return (self.expression = expression)
        }, $Map_initialize$1.$$arity = 1);
        
        Opal.def(self, '$initialize_copy', $Map_initialize_copy$2 = function $$initialize_copy(other) {
          var $iter = $Map_initialize_copy$2.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $Map_initialize_copy$2.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          $send2(self, Opal.find_super_dispatcher(self, 'initialize_copy', $Map_initialize_copy$2, false, true), 'initialize_copy', $zuper, $iter);
          return (self.node = nil);
        }, $Map_initialize_copy$2.$$arity = 1);
        
        Opal.def(self, '$node=', $Map_node$eq$3 = function(node) {
          var self = this;

          
          self.node = node;
          self.$freeze();
          return self.node;
        }, $Map_node$eq$3.$$arity = 1);
        
        Opal.def(self, '$line', $Map_line$4 = function $$line() {
          var self = this;

          return self.expression.$line()
        }, $Map_line$4.$$arity = 0);
        self.$alias_method("first_line", "line");
        
        Opal.def(self, '$column', $Map_column$5 = function $$column() {
          var self = this;

          return self.expression.$column()
        }, $Map_column$5.$$arity = 0);
        
        Opal.def(self, '$last_line', $Map_last_line$6 = function $$last_line() {
          var self = this;

          return self.expression.$last_line()
        }, $Map_last_line$6.$$arity = 0);
        
        Opal.def(self, '$last_column', $Map_last_column$7 = function $$last_column() {
          var self = this;

          return self.expression.$last_column()
        }, $Map_last_column$7.$$arity = 0);
        
        Opal.def(self, '$with_expression', $Map_with_expression$8 = function $$with_expression(expression_l) {
          var $$9, self = this;

          return $send(self, 'with', [], ($$9 = function(map){var self = $$9.$$s == null ? this : $$9.$$s;

          
            
            if (map == null) {
              map = nil;
            };
            return map.$update_expression(expression_l);}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        }, $Map_with_expression$8.$$arity = 1);
        
        Opal.def(self, '$==', $Map_$eq_eq$10 = function(other) {
          var $$11, self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = other.$class()['$=='](self.$class())))) {
            return $send(self.$instance_variables(), 'map', [], ($$11 = function(ivar){var self = $$11.$$s == null ? this : $$11.$$s;

            
              
              if (ivar == null) {
                ivar = nil;
              };
              return self.$instance_variable_get(ivar)['$=='](other.$send("instance_variable_get", ivar));}, $$11.$$s = self, $$11.$$arity = 1, $$11)).$reduce("&")
          } else {
            return $ret_or_1
          }
        }, $Map_$eq_eq$10.$$arity = 1);
        
        Opal.def(self, '$to_hash', $Map_to_hash$12 = function $$to_hash() {
          var $$13, self = this;

          return $send(self.$instance_variables(), 'inject', [$hash2([], {})], ($$13 = function(hash, ivar){var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;

          
            
            if (hash == null) {
              hash = nil;
            };
            
            if (ivar == null) {
              ivar = nil;
            };
            if (ivar.$to_sym()['$==']("@node")) {
              return hash;};
            
            $writer = [ivar['$[]']($range(1, -1, false)).$to_sym(), self.$instance_variable_get(ivar)];
            $send(hash, '[]=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            return hash;}, $$13.$$s = self, $$13.$$arity = 2, $$13))
        }, $Map_to_hash$12.$$arity = 0);
        self.$protected();
        
        Opal.def(self, '$with', $Map_with$14 = function() {
          var $iter = $Map_with$14.$$p, block = $iter || nil, self = this;

          if ($iter) $Map_with$14.$$p = null;
          
          
          if ($iter) $Map_with$14.$$p = null;;
          return $send(self.$dup(), 'tap', [], block.$to_proc());
        }, $Map_with$14.$$arity = 0);
        return (Opal.def(self, '$update_expression', $Map_update_expression$15 = function $$update_expression(expression_l) {
          var self = this;

          return (self.expression = expression_l)
        }, $Map_update_expression$15.$$arity = 1), nil) && 'update_expression';
      })($nesting[0], null, $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
