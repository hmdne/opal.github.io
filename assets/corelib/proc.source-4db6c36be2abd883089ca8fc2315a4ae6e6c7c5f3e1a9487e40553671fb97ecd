/* Generated by Opal 1.1.1 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$raise', '$proc', '$call', '$to_proc', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$>>', $Proc_$gt$gt$3 = function(other) {
      var $$4, $iter = $Proc_$gt$gt$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$gt$gt$3.$$p = null;
      return $send(self, 'proc', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(self, 'call', Opal.to_a(args), block.$to_proc());
        return other.$call(out);}, $$4.$$s = self, $$4.$$arity = -1, $$4))
    }, $Proc_$gt$gt$3.$$arity = 1);
    
    Opal.def(self, '$<<', $Proc_$lt$lt$5 = function(other) {
      var $$6, $iter = $Proc_$lt$lt$5.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$lt$lt$5.$$p = null;
      return $send(self, 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$6.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(other, 'call', Opal.to_a(args), block.$to_proc());
        return self.$call(out);}, $$6.$$s = self, $$6.$$arity = -1, $$6))
    }, $Proc_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$7.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$8 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$8.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$9 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$9.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$10 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$10.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$11 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$12 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$12.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$13 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$13.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$14 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$14.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
})(Opal);
