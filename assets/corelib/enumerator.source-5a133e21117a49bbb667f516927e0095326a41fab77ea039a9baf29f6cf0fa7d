/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$!', '$respond_to?', '$nil?', '$empty?', '$+', '$class', '$__send__', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$try_convert', '$<', '$===', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = self.size))) {
          return self.size['$respond_to?']("call")['$!']()
        } else {
          return $ret_or_1
        }; return nil; })())) {
          return (self.size = $coerce_to(self.size, $$($nesting, 'Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_2 = nil;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_2 = block['$nil?']()))) {
        return args['$empty?']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $coerce_to(offset, $$($nesting, 'Integer'), 'to_int')
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
      var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Enumerator_each_with_index$7.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Enumerator_each_with_index$7.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s;

        return self.$size()}, $$8.$$s = self, $$8.$$arity = 0, $$8))
      };
      $send2(self, Opal.find_super_dispatcher(self, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
      return self.object;
    }, $Enumerator_each_with_index$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$9.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$10 = function $$initialize() {
        var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$10.$$p = null;
        
        
        if ($iter) $Generator_initialize$10.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$10.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$11 = function $$each($a) {
        var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$11.$$p = null;
        
        
        if ($iter) $Generator_each$11.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$11.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$12 = function $$initialize() {
        var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$12.$$p = null;
        
        
        if ($iter) $Yielder_initialize$12.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$12.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$13 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$13.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$14 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self = this;

        if ($iter) $Lazy_initialize$15.$$p = null;
        
        
        if ($iter) $Lazy_initialize$15.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [size], ($$16 = function(yielder, $a){var self = $$16.$$s == null ? this : $$16.$$s, $post_args, each_args, $$17;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b){var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$17.$$s = self, $$17.$$arity = -1, $$17))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$16.$$s = self, $$16.$$arity = -2, $$16));
      }, $Lazy_initialize$15.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$18 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$18.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$19 = function $$collect() {
        var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect$19.$$p = null;
        
        
        if ($iter) $Lazy_collect$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$20 = function(enum$, $a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect$19.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self = this;

        if ($iter) $Lazy_collect_concat$21.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$21.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$22 = function(enum$, $a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args, $$23, $$24;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$23 = function(v){var self = $$23.$$s == null ? this : $$23.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$23.$$s = self, $$23.$$arity = 1, $$23))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$24 = function(v){var self = $$24.$$s == null ? this : $$24.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$24.$$s = self, $$24.$$arity = 1, $$24));
            }
          }
        ;}, $$22.$$s = self, $$22.$$arity = -2, $$22));
      }, $Lazy_collect_concat$21.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$25 = function $$drop(n) {
        var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$26 = function(enum$, $a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop$25.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
        var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$27.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$27.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$28 = function(enum$, $a){var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$28.$$s = self, $$28.$$arity = -2, $$28));
      }, $Lazy_drop_while$27.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$29.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$29.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$29.$$arity = -1);
      Opal.alias(self, "filter", "find_all");
      
      Opal.def(self, '$find_all', $Lazy_find_all$30 = function $$find_all() {
        var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;

        if ($iter) $Lazy_find_all$30.$$p = null;
        
        
        if ($iter) $Lazy_find_all$30.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$31.$$s = self, $$31.$$arity = -2, $$31));
      }, $Lazy_find_all$30.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
        var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;

        if ($iter) $Lazy_grep$32.$$p = null;
        
        
        if ($iter) $Lazy_grep$32.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$33 = function(enum$, $a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$33.$$s = self, $$33.$$arity = -2, $$33))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$34.$$s = self, $$34.$$arity = -2, $$34))
        };
      }, $Lazy_grep$32.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$35 = function $$reject() {
        var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;

        if ($iter) $Lazy_reject$35.$$p = null;
        
        
        if ($iter) $Lazy_reject$35.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$36 = function(enum$, $a){var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_reject$35.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$37 = function $$take(n) {
        var $$38, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$38 = function(enum$, $a){var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take$37.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$39 = function $$take_while() {
        var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $Lazy_take_while$39.$$p = null;
        
        
        if ($iter) $Lazy_take_while$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$40 = function(enum$, $a){var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$40.$$s = self, $$40.$$arity = -2, $$40));
      }, $Lazy_take_while$39.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$41 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
})(Opal);
