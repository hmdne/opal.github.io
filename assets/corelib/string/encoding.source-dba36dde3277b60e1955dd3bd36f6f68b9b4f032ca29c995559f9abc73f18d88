/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$11, $$14, $$17, $$20, $$23, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$require', '$+', '$[]', '$new', '$instance_eval', '$to_proc', '$each', '$const_set', '$sub', '$==', '$default_external', '$upcase', '$raise', '$attr_accessor', '$singleton_class', '$attr_reader', '$register', '$length', '$bytes', '$to_a', '$each_byte', '$dup', '$bytesize', '$enum_for', '$each_codepoint', '$coerce_to!', '$find', '$<', '$default_external=', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_to_s$7, $Encoding_inspect$8, $Encoding_each_byte$9, $Encoding_bytesize$10;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], (function() {if ($truthy(($ret_or_1 = options['$[]']("aliases")))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
      ascii = (function() {if ($truthy(($ret_or_2 = options['$[]']("ascii")))) {
        return $ret_or_2
      } else {
        return false
      }; return nil; })();
      dummy = (function() {if ($truthy(($ret_or_3 = options['$[]']("dummy")))) {
        return $ret_or_3
      } else {
        return false
      }; return nil; })();
      encoding = self.$new(name, names, ascii, dummy);
      $send(encoding, 'instance_eval', [], block.$to_proc());
      register = Opal.encodings;
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$sub("-", "_"), encoding);
        return register[encoding_name] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var self = this, register = nil, encoding = nil, $ret_or_4 = nil;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      register = Opal.encodings;
      encoding = (function() {if ($truthy(($ret_or_4 = register[name]))) {
        return $ret_or_4
      } else {
        return register[name.$upcase()]
      }; return nil; })();
      if ($truthy(encoding)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "unknown encoding name - " + (name))
      };
      return encoding;
    }, $Encoding_find$3.$$arity = 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$7 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$8 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$8.$$arity = 0);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$9 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$9.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$10 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$10.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s, $each_byte$12, $bytesize$13;

  
    
    Opal.def(self, '$each_byte', $each_byte$12 = function $$each_byte(string) {
      var $iter = $each_byte$12.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$12.$$p = null;
      
      
      if ($iter) $each_byte$12.$$p = null;;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$12.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$13 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$13.$$arity = 1), nil) && 'bytesize';}, $$11.$$s = self, $$11.$$arity = 0, $$11));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;

  
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;

  
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21, $bytesize$22;

  
    
    Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$21.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$22 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$22.$$arity = 1), nil) && 'bytesize';}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii", "dummy"], {"aliases": ["BINARY", "US-ASCII", "ASCII"], "ascii": true, "dummy": true})], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s, $each_byte$24, $bytesize$25;

  
    
    Opal.def(self, '$each_byte', $each_byte$24 = function $$each_byte(string) {
      var $iter = $each_byte$24.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$24.$$p = null;
      
      
      if ($iter) $each_byte$24.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$24.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$25 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$25.$$arity = 1), nil) && 'bytesize';}, $$23.$$s = self, $$23.$$arity = 0, $$23));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_bytes$26, $String_bytesize$27, $String_each_byte$28, $String_each_codepoint$29, $String_codepoints$30, $String_encode$31, $String_force_encoding$32, $String_getbyte$33, $String_valid_encoding$ques$34;

    self.$$prototype.bytes = self.$$prototype.internal_encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$bytes', $String_bytes$26 = function $$bytes() {
      var self = this, $ret_or_5 = nil;

      
      self.bytes = (function() {if ($truthy(($ret_or_5 = self.bytes))) {
        return $ret_or_5
      } else {
        return self.$each_byte().$to_a()
      }; return nil; })();
      return self.bytes.$dup();
    }, $String_bytes$26.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$27 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$27.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$28 = function $$each_byte() {
      var $iter = $String_each_byte$28.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_byte$28.$$p = null;
      
      
      if ($iter) $String_each_byte$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$28.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$29 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$29.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$29.$$p = null;
      
      
      if ($iter) $String_each_codepoint$29.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$29.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$30 = function $$codepoints() {
      var $iter = $String_codepoints$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$30.$$p = null;
      
      
      if ($iter) $String_codepoints$30.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$30.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$31 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$31.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$32 = function $$force_encoding(encoding) {
      var self = this;

      
      if (encoding === self.encoding) { return self; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === self.encoding) { return self; }

      Opal.set_encoding(self, encoding);

      return self;
    
    }, $String_force_encoding$32.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$33 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$33.$$arity = 1);
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$34 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$34.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
  
  $writer = [$$$($$($nesting, 'Encoding'), 'UTF_8')];
  $send($$($nesting, 'Encoding'), 'default_external=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
})(Opal);
