/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$handle', '$children', '$in_scope', '$identify!', '$scope', '$add_temp', '$process', '$inline_args', '$compile_arity_check', '$stmt', '$returned_body', '$to_vars', '$line', '$unshift', '$push', '$contains_break?', '$arity', '$arity_check?', '$compiler', '$parameters_code', '$has_top_level_mlhs_arg?', '$has_trailing_comma_in_args?', '$block_arg', '$block_name=', '$-', '$each', '$args', '$first', '$==', '$<<', '$updated', '$body', '$returns', '$s', '$any?', '$original_args', '$type', '$loc', '$expression', '$source', '$match', '$new', '$found_break?']);
  
  self.$require("opal/nodes/node_with_args");
  self.$require("opal/rewriters/break_finder");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IterNode');

        var $nesting = [self].concat($parent_nesting), $IterNode_compile$1, $IterNode_compile_block_arg$3, $IterNode_extract_underscore_args$4, $IterNode_returned_body$6, $IterNode_has_top_level_mlhs_arg$ques$7, $IterNode_has_trailing_comma_in_args$ques$9, $IterNode_arity_check_node$10, $IterNode_contains_break$ques$11;

        self.$$prototype.sexp = nil;
        
        self.$handle("iter");
        self.$children("inline_args", "body");
        
        Opal.def(self, '$compile', $IterNode_compile$1 = function $$compile() {
          var $$2, self = this, inline_params = nil, to_vars = nil, identity = nil, body_code = nil;

          
          inline_params = nil;
          to_vars = (identity = (body_code = nil));
          $send(self, 'in_scope', [], ($$2 = function(){var self = $$2.$$s == null ? this : $$2.$$s;

          
            identity = self.$scope()['$identify!']();
            self.$add_temp("" + "self = " + (identity) + ".$$s == null ? this : " + (identity) + ".$$s");
            inline_params = self.$process(self.$inline_args());
            self.$compile_arity_check();
            body_code = self.$stmt(self.$returned_body());
            return (to_vars = self.$scope().$to_vars());}, $$2.$$s = self, $$2.$$arity = 0, $$2));
          self.$line(body_code);
          self.$unshift(to_vars);
          self.$unshift("" + "(" + (identity) + " = function(", inline_params, "){");
          self.$push("" + "}, " + (identity) + ".$$s = self,");
          if ($truthy(self['$contains_break?']())) {
            self.$push("" + " " + (identity) + ".$$brk = $brk,")};
          self.$push("" + " " + (identity) + ".$$arity = " + (self.$arity()) + ",");
          if ($truthy(self.$compiler()['$arity_check?']())) {
            self.$push("" + " " + (identity) + ".$$parameters = " + (self.$parameters_code()) + ",")};
          if ($truthy(self['$has_top_level_mlhs_arg?']())) {
            self.$push("" + " " + (identity) + ".$$has_top_level_mlhs_arg = true,")};
          if ($truthy(self['$has_trailing_comma_in_args?']())) {
            self.$push("" + " " + (identity) + ".$$has_trailing_comma_in_args = true,")};
          return self.$push("" + " " + (identity) + ")");
        }, $IterNode_compile$1.$$arity = 0);
        
        Opal.def(self, '$compile_block_arg', $IterNode_compile_block_arg$3 = function $$compile_block_arg() {
          var self = this, $writer = nil, scope_name = nil;

          if ($truthy(self.$block_arg())) {
            
            
            $writer = [self.$block_arg()];
            $send(self.$scope(), 'block_name=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            self.$scope().$add_temp(self.$block_arg());
            scope_name = self.$scope()['$identify!']();
            self.$line("" + (self.$block_arg()) + " = " + (scope_name) + ".$$p || nil;");
            return self.$line("" + "if (" + (self.$block_arg()) + ") " + (scope_name) + ".$$p = null;");
          } else {
            return nil
          }
        }, $IterNode_compile_block_arg$3.$$arity = 0);
        
        Opal.def(self, '$extract_underscore_args', $IterNode_extract_underscore_args$4 = function $$extract_underscore_args() {
          var $$5, self = this, valid_args = nil, caught_blank_argument = nil;

          
          valid_args = [];
          caught_blank_argument = false;
          $send(self.$args().$children(), 'each', [], ($$5 = function(arg){var self = $$5.$$s == null ? this : $$5.$$s, arg_name = nil;

          
            
            if (arg == null) {
              arg = nil;
            };
            arg_name = arg.$children().$first();
            if (arg_name['$==']("_")) {
              if ($truthy(caught_blank_argument)) {
                return nil
              } else {
                
                caught_blank_argument = true;
                return valid_args['$<<'](arg);
              }
            } else {
              return valid_args['$<<'](arg)
            };}, $$5.$$s = self, $$5.$$arity = 1, $$5));
          return (self.sexp = self.sexp.$updated(nil, [self.$args().$updated(nil, valid_args), self.$body()]));
        }, $IterNode_extract_underscore_args$4.$$arity = 0);
        
        Opal.def(self, '$returned_body', $IterNode_returned_body$6 = function $$returned_body() {
          var self = this, $ret_or_1 = nil;

          return self.$compiler().$returns((function() {if ($truthy(($ret_or_1 = self.$body()))) {
            return $ret_or_1
          } else {
            return self.$s("nil")
          }; return nil; })())
        }, $IterNode_returned_body$6.$$arity = 0);
        
        Opal.def(self, '$has_top_level_mlhs_arg?', $IterNode_has_top_level_mlhs_arg$ques$7 = function() {
          var $$8, self = this;

          return $send(self.$original_args().$children(), 'any?', [], ($$8 = function(arg){var self = $$8.$$s == null ? this : $$8.$$s;

          
            
            if (arg == null) {
              arg = nil;
            };
            return arg.$type()['$==']("mlhs");}, $$8.$$s = self, $$8.$$arity = 1, $$8))
        }, $IterNode_has_top_level_mlhs_arg$ques$7.$$arity = 0);
        
        Opal.def(self, '$has_trailing_comma_in_args?', $IterNode_has_trailing_comma_in_args$ques$9 = function() {
          var self = this, $ret_or_2 = nil, args_source = nil;

          if ($truthy((function() {if ($truthy(($ret_or_2 = self.$original_args().$loc()))) {
            return self.$original_args().$loc().$expression()
          } else {
            return $ret_or_2
          }; return nil; })())) {
            
            args_source = self.$original_args().$loc().$expression().$source();
            return args_source.$match(/,\s*\|/);
          } else {
            return nil
          }
        }, $IterNode_has_trailing_comma_in_args$ques$9.$$arity = 0);
        
        Opal.def(self, '$arity_check_node', $IterNode_arity_check_node$10 = function $$arity_check_node() {
          var self = this;

          return self.$s("iter_arity_check", self.$original_args())
        }, $IterNode_arity_check_node$10.$$arity = 0);
        return (Opal.def(self, '$contains_break?', $IterNode_contains_break$ques$11 = function() {
          var self = this, finder = nil;

          
          finder = $$$($$$($$($nesting, 'Opal'), 'Rewriters'), 'BreakFinder').$new();
          finder.$process(self.sexp);
          return finder['$found_break?']();
        }, $IterNode_contains_break$ques$11.$$arity = 0), nil) && 'contains_break?';
      })($nesting[0], $$($nesting, 'NodeWithArgs'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
})(Opal);
