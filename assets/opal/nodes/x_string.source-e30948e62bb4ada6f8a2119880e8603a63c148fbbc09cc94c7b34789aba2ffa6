/* Generated by Opal 1.1.1 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $lambda = Opal.lambda;

  Opal.add_stubs(['$handle', '$unpack_return', '$children', '$strip_empty_children', '$single_line?', '$compile_single_line', '$each', '$compile_child', '$recv?', '$wrap', '$push', '$private', '$type', '$===', '$source', '$expression', '$loc', '$new', '$scope', '$expr', '$raise', '$shift', '$empty?', '$s', '$==', '$strip', '$=~', '$!', '$pop', '$extract_last_value', '$rstrip', '$expr?', '$end_with?', '$warning', '$compiler', '$line', '$[]', '$size', '$none?', '$first', '$dup', '$nil?', '$any?', '$last']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'XStringNode');

        var $nesting = [self].concat($parent_nesting), $XStringNode_compile$1, $XStringNode_compile_child$3, $XStringNode_compile_single_line$4, $XStringNode_extract_last_value$6, $XStringNode_single_line$ques$7, $XStringNode_unpack_return$9, $XStringNode_strip_empty_children$10;

        self.$$prototype.should_add_semicolon = self.$$prototype.returning = nil;
        
        self.$handle("xstr");
        
        Opal.def(self, '$compile', $XStringNode_compile$1 = function $$compile() {
          var $$2, self = this, unpacked_children = nil, stripped_children = nil;

          
          self.should_add_semicolon = false;
          unpacked_children = self.$unpack_return(self.$children());
          stripped_children = self.$strip_empty_children(unpacked_children);
          if ($truthy(self['$single_line?'](stripped_children))) {
            self.$compile_single_line(stripped_children)
          } else {
            $send(unpacked_children, 'each', [], ($$2 = function(c){var self = $$2.$$s == null ? this : $$2.$$s;

            
              
              if (c == null) {
                c = nil;
              };
              return self.$compile_child(c);}, $$2.$$s = self, $$2.$$arity = 1, $$2))
          };
          if ($truthy(self['$recv?']())) {
            self.$wrap("(", ")")};
          if ($truthy(self.should_add_semicolon)) {
            return self.$push(";")
          } else {
            return nil
          };
        }, $XStringNode_compile$1.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$compile_child', $XStringNode_compile_child$3 = function $$compile_child(child) {
          var self = this, $case = nil, value = nil;

          return (function() {$case = child.$type();
          if ("str"['$===']($case)) {
          value = child.$loc().$expression().$source();
          return self.$push($$($nesting, 'Fragment').$new(value, self.$scope(), child));}
          else if ("begin"['$===']($case) || "gvar"['$===']($case) || "ivar"['$===']($case) || "nil"['$===']($case)) {return self.$push(self.$expr(child))}
          else {return self.$raise("" + "Unsupported xstr part: " + (child.$type()))}})()
        }, $XStringNode_compile_child$3.$$arity = 1);
        
        Opal.def(self, '$compile_single_line', $XStringNode_compile_single_line$4 = function $$compile_single_line(children) {
          var $$5, self = this, has_embeded_return = nil, first_child = nil, single_child = nil, $ret_or_1 = nil, first_value = nil, $ret_or_2 = nil, last_child = nil, $ret_or_3 = nil, last_value = nil;

          
          has_embeded_return = false;
          first_child = children.$shift();
          single_child = children['$empty?']();
          first_child = (function() {if ($truthy(($ret_or_1 = first_child))) {
            return $ret_or_1
          } else {
            return self.$s("nil")
          }; return nil; })();
          if (first_child.$type()['$==']("str")) {
            
            first_value = first_child.$loc().$expression().$source().$strip();
            has_embeded_return = first_value['$=~'](/^return\b/);};
          if ($truthy((function() {if ($truthy(($ret_or_2 = self.returning))) {
            return has_embeded_return['$!']()
          } else {
            return $ret_or_2
          }; return nil; })())) {
            self.$push("return ")};
          last_child = (function() {if ($truthy(($ret_or_3 = children.$pop()))) {
            return $ret_or_3
          } else {
            return first_child
          }; return nil; })();
          if (last_child.$type()['$==']("str")) {
            last_value = self.$extract_last_value(last_child)};
          if ($truthy(single_child)) {
          } else {
            
            self.should_add_semicolon = false;
            self.$compile_child(first_child);
            $send(children, 'each', [], ($$5 = function(c){var self = $$5.$$s == null ? this : $$5.$$s;

            
              
              if (c == null) {
                c = nil;
              };
              return self.$compile_child(c);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
          };
          if (last_child.$type()['$==']("str")) {
            return self.$push($$($nesting, 'Fragment').$new(last_value, self.$scope(), last_child))
          } else {
            return self.$compile_child(last_child)
          };
        }, $XStringNode_compile_single_line$4.$$arity = 1);
        
        Opal.def(self, '$extract_last_value', $XStringNode_extract_last_value$6 = function $$extract_last_value(last_child) {
          var self = this, last_value = nil, $ret_or_4 = nil, $ret_or_5 = nil;

          
          last_value = last_child.$loc().$expression().$source().$rstrip();
          if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.returning))) {
            return $ret_or_5
          } else {
            return self['$expr?']()
          }; return nil; })()))) {
            return last_value['$end_with?'](";")
          } else {
            return $ret_or_4
          }; return nil; })())) {
            
            self.$compiler().$warning("Removed semicolon ending x-string expression, interpreted as unintentional", last_child.$line());
            last_value = last_value['$[]']($range(0, -2, false));};
          if ($truthy(self.returning)) {
            self.should_add_semicolon = true};
          return last_value;
        }, $XStringNode_extract_last_value$6.$$arity = 1);
        
        Opal.def(self, '$single_line?', $XStringNode_single_line$ques$7 = function(children) {
          var $$8, self = this, $ret_or_6 = nil;

          if ($truthy(($ret_or_6 = children.$size()['$=='](1)))) {
            return $ret_or_6
          } else {
            return $send(children, 'none?', [], ($$8 = function(c){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_7 = nil;

            
              
              if (c == null) {
                c = nil;
              };
              if ($truthy(($ret_or_7 = c.$type()['$==']("str")))) {
                return c.$loc().$expression().$source()['$end_with?']("\n")
              } else {
                return $ret_or_7
              };}, $$8.$$s = self, $$8.$$arity = 1, $$8))
          }
        }, $XStringNode_single_line$ques$7.$$arity = 1);
        
        Opal.def(self, '$unpack_return', $XStringNode_unpack_return$9 = function $$unpack_return(children) {
          var self = this, first_child = nil;

          
          first_child = children.$first();
          self.returning = false;
          if (first_child.$type()['$==']("js_return")) {
            
            self.returning = true;
            children = first_child.$children();};
          return children;
        }, $XStringNode_unpack_return$9.$$arity = 1);
        return (Opal.def(self, '$strip_empty_children', $XStringNode_strip_empty_children$10 = function $$strip_empty_children(children) {
          var $$11, $a, self = this, empty_line = nil, $ret_or_10 = nil, $ret_or_11 = nil;

          
          children = children.$dup();
          empty_line = $lambda(($$11 = function(child){var self = $$11.$$s == null ? this : $$11.$$s, $ret_or_8 = nil, $ret_or_9 = nil;

          
            
            if (child == null) {
              child = nil;
            };
            if ($truthy(($ret_or_8 = child['$nil?']()))) {
              return $ret_or_8
            } else {
              
              if ($truthy(($ret_or_9 = child.$type()['$==']("str")))) {
                return child.$loc().$expression().$source().$rstrip()['$empty?']()
              } else {
                return $ret_or_9
              };
            };}, $$11.$$s = self, $$11.$$arity = 1, $$11));
          while ($truthy((function() {if ($truthy(($ret_or_10 = children['$any?']()))) {
            return empty_line['$[]'](children.$first())
          } else {
            return $ret_or_10
          }; return nil; })())) {
            children.$shift()
          };
          while ($truthy((function() {if ($truthy(($ret_or_11 = children['$any?']()))) {
            return empty_line['$[]'](children.$last())
          } else {
            return $ret_or_11
          }; return nil; })())) {
            children.$pop()
          };
          return children;
        }, $XStringNode_strip_empty_children$10.$$arity = 1), nil) && 'strip_empty_children';
      })($nesting[0], $$($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
})(Opal);
