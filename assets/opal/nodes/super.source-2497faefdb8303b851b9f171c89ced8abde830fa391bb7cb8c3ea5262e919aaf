/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $send2 = Opal.send2, $slice = Opal.slice, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include?', '$type', '$s', '$helper', '$push', '$compile_receiver', '$compile_method_body', '$compile_method_name', '$compile_arguments', '$compile_block_pass', '$private', '$def?', '$scope', '$find_parent_def', '$==', '$raise_exception?', '$implicit_args?', '$to_s', '$mid', '$def_scope', '$identify!', '$method_id', '$def_scope_identity', '$defined_check_param', '$allow_stubs', '$super_chain', '$join', '$map', '$implicit_arguments_param', '$super_method_invocation', '$iter?', '$super_block_invocation', '$raise', '$handle', '$wrap', '$uses_block!', '$compile_using_send', '$iter', '$uses_zuper=', '$-', '$block_name', '$!', '$<<', '$empty?', '$children', '$arglist', '$expr', '$===']);
  
  self.$require("opal/nodes/base");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BaseSuperNode');

        var $nesting = [self].concat($parent_nesting), $BaseSuperNode_initialize$1, $BaseSuperNode_compile_using_send$2, $BaseSuperNode_def_scope$3, $BaseSuperNode_raise_exception$ques$4, $BaseSuperNode_defined_check_param$5, $BaseSuperNode_implicit_args$ques$6, $BaseSuperNode_implicit_arguments_param$7, $BaseSuperNode_method_id$8, $BaseSuperNode_def_scope_identity$9, $BaseSuperNode_allow_stubs$10, $BaseSuperNode_super_method_invocation$11, $BaseSuperNode_super_block_invocation$12, $BaseSuperNode_compile_method_body$14, $BaseSuperNode_compile_method_name$15;

        self.$$prototype.sexp = self.$$prototype.def_scope = nil;
        
        
        Opal.def(self, '$initialize', $BaseSuperNode_initialize$1 = function $$initialize($a) {
          var $post_args, $b, $c, $iter = $BaseSuperNode_initialize$1.$$p, $yield = $iter || nil, self = this, args = nil, rest = nil, last_child = nil, $ret_or_1 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $BaseSuperNode_initialize$1.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          ;
          $send2(self, Opal.find_super_dispatcher(self, 'initialize', $BaseSuperNode_initialize$1, false, true), 'initialize', $zuper, $iter);
          args = [].concat(Opal.to_a(self.sexp));
          $b = [].concat(Opal.to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_child = ($b[$c] == null ? nil : $b[$c])), $b;
          if ($truthy((function() {if ($truthy(($ret_or_1 = last_child))) {
            return ["iter", "block_pass"]['$include?'](last_child.$type())
          } else {
            return $ret_or_1
          }; return nil; })())) {
            
            self.iter = last_child;
            args = rest;
          } else {
            self.iter = self.$s("js_tmp", "null")
          };
          self.arglist = $send(self, 's', ["arglist"].concat(Opal.to_a(args)));
          return (self.recvr = self.$s("self"));
        }, $BaseSuperNode_initialize$1.$$arity = -1);
        
        Opal.def(self, '$compile_using_send', $BaseSuperNode_compile_using_send$2 = function $$compile_using_send() {
          var self = this;

          
          self.$helper("send2");
          self.$push("$send2(");
          self.$compile_receiver();
          self.$compile_method_body();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        }, $BaseSuperNode_compile_using_send$2.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$def_scope', $BaseSuperNode_def_scope$3 = function $$def_scope() {
          var self = this, $ret_or_2 = nil;

          return (self.def_scope = (function() {if ($truthy(($ret_or_2 = self.def_scope))) {
            return $ret_or_2
          } else if ($truthy(self.$scope()['$def?']())) {
            return self.$scope()
          } else {
            return self.$scope().$find_parent_def()
          }; return nil; })())
        }, $BaseSuperNode_def_scope$3.$$arity = 0);
        
        Opal.def(self, '$raise_exception?', $BaseSuperNode_raise_exception$ques$4 = function() {
          var self = this;

          return self.sexp.$type()['$==']("defined_super")
        }, $BaseSuperNode_raise_exception$ques$4.$$arity = 0);
        
        Opal.def(self, '$defined_check_param', $BaseSuperNode_defined_check_param$5 = function $$defined_check_param() {
          var self = this;

          if ($truthy(self['$raise_exception?']())) {
            return "true"
          } else {
            return "false"
          }
        }, $BaseSuperNode_defined_check_param$5.$$arity = 0);
        
        Opal.def(self, '$implicit_args?', $BaseSuperNode_implicit_args$ques$6 = function() {
          var self = this;

          return self.sexp.$type()['$==']("zsuper")
        }, $BaseSuperNode_implicit_args$ques$6.$$arity = 0);
        
        Opal.def(self, '$implicit_arguments_param', $BaseSuperNode_implicit_arguments_param$7 = function $$implicit_arguments_param() {
          var self = this;

          if ($truthy(self['$implicit_args?']())) {
            return "true"
          } else {
            return "false"
          }
        }, $BaseSuperNode_implicit_arguments_param$7.$$arity = 0);
        
        Opal.def(self, '$method_id', $BaseSuperNode_method_id$8 = function $$method_id() {
          var self = this;

          return self.$def_scope().$mid().$to_s()
        }, $BaseSuperNode_method_id$8.$$arity = 0);
        
        Opal.def(self, '$def_scope_identity', $BaseSuperNode_def_scope_identity$9 = function $$def_scope_identity() {
          var self = this;

          return self.$def_scope()['$identify!'](self.$def_scope().$mid())
        }, $BaseSuperNode_def_scope_identity$9.$$arity = 0);
        
        Opal.def(self, '$allow_stubs', $BaseSuperNode_allow_stubs$10 = function $$allow_stubs() {
          var self = this;

          return true
        }, $BaseSuperNode_allow_stubs$10.$$arity = 0);
        
        Opal.def(self, '$super_method_invocation', $BaseSuperNode_super_method_invocation$11 = function $$super_method_invocation() {
          var self = this;

          return "" + "Opal.find_super_dispatcher(self, '" + (self.$method_id()) + "', " + (self.$def_scope_identity()) + ", " + (self.$defined_check_param()) + ", " + (self.$allow_stubs()) + ")"
        }, $BaseSuperNode_super_method_invocation$11.$$arity = 0);
        
        Opal.def(self, '$super_block_invocation', $BaseSuperNode_super_block_invocation$12 = function $$super_block_invocation() {
          var $a, $b, $$13, self = this, chain = nil, cur_defn = nil, mid = nil, trys = nil;

          
          $b = self.$scope().$super_chain(), $a = Opal.to_ary($b), (chain = ($a[0] == null ? nil : $a[0])), (cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
          trys = $send(chain, 'map', [], ($$13 = function(c){var self = $$13.$$s == null ? this : $$13.$$s;

          
            
            if (c == null) {
              c = nil;
            };
            return "" + (c) + ".$$def";}, $$13.$$s = self, $$13.$$arity = 1, $$13)).$join(" || ");
          return "" + "Opal.find_iter_super_dispatcher(self, " + (mid) + ", (" + (trys) + " || " + (cur_defn) + "), " + (self.$defined_check_param()) + ", " + (self.$implicit_arguments_param()) + ")";
        }, $BaseSuperNode_super_block_invocation$12.$$arity = 0);
        
        Opal.def(self, '$compile_method_body', $BaseSuperNode_compile_method_body$14 = function $$compile_method_body() {
          var self = this;

          
          self.$push(", ");
          if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$super_method_invocation())
          } else if ($truthy(self.$scope()['$iter?']())) {
            return self.$push(self.$super_block_invocation())
          } else {
            return self.$raise("super must be called from method body or block")
          };
        }, $BaseSuperNode_compile_method_body$14.$$arity = 0);
        return (Opal.def(self, '$compile_method_name', $BaseSuperNode_compile_method_name$15 = function $$compile_method_name() {
          var $a, $b, self = this, _chain = nil, _cur_defn = nil, mid = nil;

          if ($truthy(self.$scope()['$def?']())) {
            return self.$push("" + ", '" + (self.$method_id()) + "'")
          } else if ($truthy(self.$scope()['$iter?']())) {
            
            $b = self.$scope().$super_chain(), $a = Opal.to_ary($b), (_chain = ($a[0] == null ? nil : $a[0])), (_cur_defn = ($a[1] == null ? nil : $a[1])), (mid = ($a[2] == null ? nil : $a[2])), $b;
            return self.$push("" + ", " + (mid));
          } else {
            return nil
          }
        }, $BaseSuperNode_compile_method_name$15.$$arity = 0), nil) && 'compile_method_name';
      })($nesting[0], $$($nesting, 'CallNode'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DefinedSuperNode');

        var $nesting = [self].concat($parent_nesting), $DefinedSuperNode_allow_stubs$16, $DefinedSuperNode_compile$17;

        
        self.$handle("defined_super");
        
        Opal.def(self, '$allow_stubs', $DefinedSuperNode_allow_stubs$16 = function $$allow_stubs() {
          var self = this;

          return false
        }, $DefinedSuperNode_allow_stubs$16.$$arity = 0);
        return (Opal.def(self, '$compile', $DefinedSuperNode_compile$17 = function $$compile() {
          var self = this;

          
          self.$compile_receiver();
          self.$compile_method_body();
          return self.$wrap("((", ") != null ? \"super\" : nil)");
        }, $DefinedSuperNode_compile$17.$$arity = 0), nil) && 'compile';
      })($nesting[0], $$($nesting, 'BaseSuperNode'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'SuperNode');

        var $nesting = [self].concat($parent_nesting), $SuperNode_initialize$18, $SuperNode_compile$19;

        
        self.$handle("super");
        
        Opal.def(self, '$initialize', $SuperNode_initialize$18 = function $$initialize($a) {
          var $post_args, $iter = $SuperNode_initialize$18.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $SuperNode_initialize$18.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          ;
          $send2(self, Opal.find_super_dispatcher(self, 'initialize', $SuperNode_initialize$18, false, true), 'initialize', $zuper, $iter);
          if ($truthy(self.$scope()['$def?']())) {
            return self.$scope()['$uses_block!']()
          } else {
            return nil
          };
        }, $SuperNode_initialize$18.$$arity = -1);
        return (Opal.def(self, '$compile', $SuperNode_compile$19 = function $$compile() {
          var self = this;

          return self.$compile_using_send()
        }, $SuperNode_compile$19.$$arity = 0), nil) && 'compile';
      })($nesting[0], $$($nesting, 'BaseSuperNode'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'ZsuperNode');

        var $nesting = [self].concat($parent_nesting), $ZsuperNode_initialize$20, $ZsuperNode_compile$21, $ZsuperNode_compile_arguments$22, $ZsuperNode_block_name$23;

        
        self.$handle("zsuper");
        
        Opal.def(self, '$initialize', $ZsuperNode_initialize$20 = function $$initialize($a) {
          var $post_args, $iter = $ZsuperNode_initialize$20.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $ZsuperNode_initialize$20.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          ;
          $send2(self, Opal.find_super_dispatcher(self, 'initialize', $ZsuperNode_initialize$20, false, true), 'initialize', $zuper, $iter);
          if (self.$iter().$type()['$==']("iter")) {
            return nil
          } else {
            
            self.$scope()['$uses_block!']();
            return (self.iter = self.$s("js_tmp", "$iter"));
          };
        }, $ZsuperNode_initialize$20.$$arity = -1);
        
        Opal.def(self, '$compile', $ZsuperNode_compile$21 = function $$compile() {
          var self = this, $writer = nil, implicit_args = nil, $ret_or_3 = nil, block_pass = nil;

          
          if ($truthy(self.$def_scope())) {
            
            
            $writer = [true];
            $send(self.$def_scope(), 'uses_zuper=', Opal.to_a($writer));
            $writer[$rb_minus($writer["length"], 1)];;
            implicit_args = [self.$s("js_tmp", "$zuper")];
            if ($truthy((function() {if ($truthy(($ret_or_3 = self.$block_name()))) {
              return self.$iter()['$!']()
            } else {
              return $ret_or_3
            }; return nil; })())) {
              
              block_pass = self.$s("block_pass", self.$s("lvar", self.$block_name()));
              implicit_args['$<<'](block_pass);};
            self.arglist = $send(self, 's', ["arglist"].concat(Opal.to_a(implicit_args)));};
          return self.$compile_using_send();
        }, $ZsuperNode_compile$21.$$arity = 0);
        
        Opal.def(self, '$compile_arguments', $ZsuperNode_compile_arguments$22 = function $$compile_arguments() {
          var self = this;

          
          self.$push(", ");
          if ($truthy(self.$arglist().$children()['$empty?']())) {
            return self.$push("[]")
          } else {
            return self.$push(self.$expr(self.$arglist()))
          };
        }, $ZsuperNode_compile_arguments$22.$$arity = 0);
        return (Opal.def(self, '$block_name', $ZsuperNode_block_name$23 = function $$block_name() {
          var self = this, $case = nil;

          return (function() {$case = self.$def_scope();
          if ($$$($$$($$($nesting, 'Opal'), 'Nodes'), 'IterNode')['$===']($case)) {return self.$def_scope().$block_name()}
          else if ($$$($$$($$($nesting, 'Opal'), 'Nodes'), 'DefNode')['$===']($case)) {return self.$def_scope().$block_name()}
          else {return self.$raise("" + "Don't know what to do with super in the scope " + (self.$def_scope()))}})()
        }, $ZsuperNode_block_name$23.$$arity = 0), nil) && 'block_name';
      })($nesting[0], $$($nesting, 'SuperNode'), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
})(Opal);
