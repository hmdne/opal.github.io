/* Generated by Opal 1.1.1 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send = Opal.send, $send2 = Opal.send2, $slice = Opal.slice, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$handle', '$attr_reader', '$freeze', '$[]=', '$-', '$define_method', '$to_proc', '$include?', '$type', '$s', '$handle_special', '$record_method?', '$<<', '$method_calls', '$compiler', '$to_sym', '$meth', '$using_irb?', '$compile_irb_var', '$default_compile', '$private', '$iter', '$new', '$process', '$found_break?', '$splat?', '$invoke_using_send?', '$compile_using_send', '$compile_simple_call_chain', '$compile_break_catcher', '$helper', '$push', '$compile_receiver', '$compile_method_name', '$compile_arguments', '$compile_block_pass', '$recv', '$receiver_sexp', '$expr', '$arglist', '$empty?', '$children', '$iter_has_break?', '$unshift', '$line', '$method_jsid', '$any?', '$==', '$recvr', '$mid_to_jsid', '$to_s', '$with_temp', '$intern', '$irb?', '$top?', '$scope', '$nil?', '$updated', '$method', '$arity', '$[]', '$each', '$add_special', '$inline_operators?', '$operator_helpers', '$fragment', '$call', '$resolve', '$requires', '$file', '$dirname', '$cleanpath', '$join', '$Pathname', '$inspect', '$class_scope?', '$required_trees', '$force_encoding', '$encoding', '$+', '$handle_block_given_call', '$def?', '$mid', '$arity_check?', '$push_nesting?', '$first', '$size', '$last', '$handle_part', '$map', '$is_a?', '$expand_path', '$split', '$dynamic_require_severity', '$===', '$error', '$warning', '$each_with_object', '$pop']);
  
  self.$require("set");
  self.$require("pathname");
  self.$require("opal/nodes/base");
  self.$require("opal/rewriters/break_finder");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    (function($base, $parent_nesting) {
      var self = $module($base, 'Nodes');

      var $nesting = [self].concat($parent_nesting);

      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CallNode');

        var $nesting = [self].concat($parent_nesting), $CallNode_add_special$1, $CallNode_initialize$2, $CallNode_compile$3, $CallNode_iter_has_break$ques$5, $CallNode_invoke_using_send$ques$6, $CallNode_default_compile$7, $CallNode_compile_using_send$8, $CallNode_compile_receiver$9, $CallNode_compile_method_name$10, $CallNode_compile_arguments$11, $CallNode_compile_block_pass$12, $CallNode_compile_break_catcher$13, $CallNode_compile_simple_call_chain$14, $CallNode_splat$ques$15, $CallNode_receiver_sexp$17, $CallNode_method_jsid$18, $CallNode_record_method$ques$19, $CallNode_compile_irb_var$20, $CallNode_using_irb$ques$22, $CallNode_sexp_with_arglist$23, $CallNode_handle_special$24, $CallNode$25, $CallNode$27, $CallNode$28, $CallNode$29, $CallNode$30, $CallNode$31, $CallNode$32, $CallNode$33, $CallNode$34, $CallNode$35, $CallNode$36, $CallNode$37, $CallNode_push_nesting$ques$38;

        self.$$prototype.sexp = self.$$prototype.compiler = nil;
        
        self.$handle("send");
        self.$attr_reader("recvr", "meth", "arglist", "iter");
        Opal.const_set($nesting[0], 'SPECIALS', $hash2([], {}));
        Opal.const_set($nesting[0], 'OPERATORS', $hash2(["+", "-", "*", "/", "<", "<=", ">", ">="], {"+": "plus", "-": "minus", "*": "times", "/": "divide", "<": "lt", "<=": "le", ">": "gt", ">=": "ge"}).$freeze());
        Opal.defs(self, '$add_special', $CallNode_add_special$1 = function $$add_special(name, options) {
          var $iter = $CallNode_add_special$1.$$p, handler = $iter || nil, self = this, $writer = nil;

          if ($iter) $CallNode_add_special$1.$$p = null;
          
          
          if ($iter) $CallNode_add_special$1.$$p = null;;
          
          if (options == null) {
            options = $hash2([], {});
          };
          
          $writer = [name, options];
          $send($$($nesting, 'SPECIALS'), '[]=', Opal.to_a($writer));
          $writer[$rb_minus($writer["length"], 1)];;
          return $send(self, 'define_method', ["" + "handle_" + (name)], handler.$to_proc());
        }, $CallNode_add_special$1.$$arity = -2);
        
        Opal.def(self, '$initialize', $CallNode_initialize$2 = function $$initialize($a) {
          var $post_args, $b, $c, $iter = $CallNode_initialize$2.$$p, $yield = $iter || nil, self = this, args = nil, rest = nil, last_arg = nil, $ret_or_1 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

          if ($iter) $CallNode_initialize$2.$$p = null;
          // Prepare super implicit arguments
          for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
            $zuper[$zuper_i] = arguments[$zuper_i];
          }
          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          ;
          $send2(self, Opal.find_super_dispatcher(self, 'initialize', $CallNode_initialize$2, false, true), 'initialize', $zuper, $iter);
          $b = [].concat(Opal.to_a(self.sexp)), (self.recvr = ($b[0] == null ? nil : $b[0])), (self.meth = ($b[1] == null ? nil : $b[1])), (args = $slice.call($b, 2)), $b;
          $b = [].concat(Opal.to_a(args)), $c = $b.length - 1, $c = ($c < 0) ? 0 : $c, (rest = $slice.call($b, 0, $c)), (last_arg = ($b[$c] == null ? nil : $b[$c])), $b;
          if ($truthy((function() {if ($truthy(($ret_or_1 = last_arg))) {
            return ["iter", "block_pass"]['$include?'](last_arg.$type())
          } else {
            return $ret_or_1
          }; return nil; })())) {
            
            self.iter = last_arg;
            args = rest;
          } else {
            self.iter = nil
          };
          return (self.arglist = $send(self, 's', ["arglist"].concat(Opal.to_a(args))));
        }, $CallNode_initialize$2.$$arity = -1);
        
        Opal.def(self, '$compile', $CallNode_compile$3 = function $$compile() {try {

          var $$4, self = this;

          return $send(self, 'handle_special', [], ($$4 = function(){var self = $$4.$$s == null ? this : $$4.$$s;

          
            if ($truthy(self['$record_method?']())) {
              self.$compiler().$method_calls()['$<<'](self.$meth().$to_sym())};
            if ($truthy(self['$using_irb?']())) {
              Opal.ret(self.$compile_irb_var())};
            return self.$default_compile();}, $$4.$$s = self, $$4.$$arity = 0, $$4))
          } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
        }, $CallNode_compile$3.$$arity = 0);
        self.$private();
        
        Opal.def(self, '$iter_has_break?', $CallNode_iter_has_break$ques$5 = function() {
          var self = this, finder = nil;

          
          if ($truthy(self.$iter())) {
          } else {
            return false
          };
          finder = $$$($$$($$($nesting, 'Opal'), 'Rewriters'), 'BreakFinder').$new();
          finder.$process(self.$iter());
          return finder['$found_break?']();
        }, $CallNode_iter_has_break$ques$5.$$arity = 0);
        
        Opal.def(self, '$invoke_using_send?', $CallNode_invoke_using_send$ques$6 = function() {
          var self = this, $ret_or_2 = nil;

          if ($truthy(($ret_or_2 = self.$iter()))) {
            return $ret_or_2
          } else {
            return self['$splat?']()
          }
        }, $CallNode_invoke_using_send$ques$6.$$arity = 0);
        
        Opal.def(self, '$default_compile', $CallNode_default_compile$7 = function $$default_compile() {
          var self = this;

          
          if ($truthy(self['$invoke_using_send?']())) {
            self.$compile_using_send()
          } else {
            self.$compile_simple_call_chain()
          };
          return self.$compile_break_catcher();
        }, $CallNode_default_compile$7.$$arity = 0);
        
        Opal.def(self, '$compile_using_send', $CallNode_compile_using_send$8 = function $$compile_using_send() {
          var self = this;

          
          self.$helper("send");
          self.$push("$send(");
          self.$compile_receiver();
          self.$compile_method_name();
          self.$compile_arguments();
          self.$compile_block_pass();
          return self.$push(")");
        }, $CallNode_compile_using_send$8.$$arity = 0);
        
        Opal.def(self, '$compile_receiver', $CallNode_compile_receiver$9 = function $$compile_receiver() {
          var self = this;

          return self.$push(self.$recv(self.$receiver_sexp()))
        }, $CallNode_compile_receiver$9.$$arity = 0);
        
        Opal.def(self, '$compile_method_name', $CallNode_compile_method_name$10 = function $$compile_method_name() {
          var self = this;

          return self.$push("" + ", '" + (self.$meth()) + "'")
        }, $CallNode_compile_method_name$10.$$arity = 0);
        
        Opal.def(self, '$compile_arguments', $CallNode_compile_arguments$11 = function $$compile_arguments() {
          var self = this;

          
          self.$push(", ");
          if ($truthy(self['$splat?']())) {
            return self.$push(self.$expr(self.$arglist()))
          } else if ($truthy(self.$arglist().$children()['$empty?']())) {
            return self.$push("[]")
          } else {
            return self.$push("[", self.$expr(self.$arglist()), "]")
          };
        }, $CallNode_compile_arguments$11.$$arity = 0);
        
        Opal.def(self, '$compile_block_pass', $CallNode_compile_block_pass$12 = function $$compile_block_pass() {
          var self = this;

          if ($truthy(self.$iter())) {
            return self.$push(", ", self.$expr(self.$iter()))
          } else {
            return nil
          }
        }, $CallNode_compile_block_pass$12.$$arity = 0);
        
        Opal.def(self, '$compile_break_catcher', $CallNode_compile_break_catcher$13 = function $$compile_break_catcher() {
          var self = this;

          if ($truthy(self['$iter_has_break?']())) {
            
            self.$unshift("return ");
            self.$unshift("(function(){var $brk = Opal.new_brk(); try {");
            return self.$line("} catch (err) { if (err === $brk) { return err.$v } else { throw err } }})()");
          } else {
            return nil
          }
        }, $CallNode_compile_break_catcher$13.$$arity = 0);
        
        Opal.def(self, '$compile_simple_call_chain', $CallNode_compile_simple_call_chain$14 = function $$compile_simple_call_chain() {
          var self = this;

          return self.$push(self.$recv(self.$receiver_sexp()), self.$method_jsid(), "(", self.$expr(self.$arglist()), ")")
        }, $CallNode_compile_simple_call_chain$14.$$arity = 0);
        
        Opal.def(self, '$splat?', $CallNode_splat$ques$15 = function() {
          var $$16, self = this;

          return $send(self.$arglist().$children(), 'any?', [], ($$16 = function(a){var self = $$16.$$s == null ? this : $$16.$$s;

          
            
            if (a == null) {
              a = nil;
            };
            return a.$type()['$==']("splat");}, $$16.$$s = self, $$16.$$arity = 1, $$16))
        }, $CallNode_splat$ques$15.$$arity = 0);
        
        Opal.def(self, '$receiver_sexp', $CallNode_receiver_sexp$17 = function $$receiver_sexp() {
          var self = this, $ret_or_3 = nil;

          if ($truthy(($ret_or_3 = self.$recvr()))) {
            return $ret_or_3
          } else {
            return self.$s("self")
          }
        }, $CallNode_receiver_sexp$17.$$arity = 0);
        
        Opal.def(self, '$method_jsid', $CallNode_method_jsid$18 = function $$method_jsid() {
          var self = this;

          return self.$mid_to_jsid(self.$meth().$to_s())
        }, $CallNode_method_jsid$18.$$arity = 0);
        
        Opal.def(self, '$record_method?', $CallNode_record_method$ques$19 = function() {
          var self = this;

          return true
        }, $CallNode_record_method$ques$19.$$arity = 0);
        
        Opal.def(self, '$compile_irb_var', $CallNode_compile_irb_var$20 = function $$compile_irb_var() {
          var $$21, self = this;

          return $send(self, 'with_temp', [], ($$21 = function(tmp){var self = $$21.$$s == null ? this : $$21.$$s, lvar = nil, call = nil;

          
            
            if (tmp == null) {
              tmp = nil;
            };
            lvar = self.$meth();
            call = self.$s("send", self.$s("self"), self.$meth().$intern(), self.$s("arglist"));
            return self.$push("" + "((" + (tmp) + " = Opal.irb_vars." + (lvar) + ") == null ? ", self.$expr(call), "" + " : " + (tmp) + ")");}, $$21.$$s = self, $$21.$$arity = 1, $$21))
        }, $CallNode_compile_irb_var$20.$$arity = 0);
        
        Opal.def(self, '$using_irb?', $CallNode_using_irb$ques$22 = function() {
          var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil;

          if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = (function() {if ($truthy(($ret_or_7 = self.compiler['$irb?']()))) {
            return self.$scope()['$top?']()
          } else {
            return $ret_or_7
          }; return nil; })()))) {
            return self.$arglist()['$=='](self.$s("arglist"))
          } else {
            return $ret_or_6
          }; return nil; })()))) {
            return self.$recvr()['$nil?']()
          } else {
            return $ret_or_5
          }; return nil; })()))) {
            return self.$iter()['$nil?']()
          } else {
            return $ret_or_4
          }
        }, $CallNode_using_irb$ques$22.$$arity = 0);
        
        Opal.def(self, '$sexp_with_arglist', $CallNode_sexp_with_arglist$23 = function $$sexp_with_arglist() {
          var self = this;

          return self.sexp.$updated(nil, [self.$recvr(), self.$meth(), self.$arglist()])
        }, $CallNode_sexp_with_arglist$23.$$arity = 0);
        
        Opal.def(self, '$handle_special', $CallNode_handle_special$24 = function $$handle_special() {
          var $iter = $CallNode_handle_special$24.$$p, compile_default = $iter || nil, self = this, method = nil;

          if ($iter) $CallNode_handle_special$24.$$p = null;
          
          
          if ($iter) $CallNode_handle_special$24.$$p = null;;
          if ($truthy($$($nesting, 'SPECIALS')['$include?'](self.$meth()))) {
            
            method = self.$method("" + "handle_" + (self.$meth()));
            if (method.$arity()['$=='](1)) {
              return method['$[]'](compile_default)
            } else {
              return method['$[]']()
            };
          } else {
            return Opal.yieldX(compile_default, []);
          };
        }, $CallNode_handle_special$24.$$arity = 0);
        $send($$($nesting, 'OPERATORS'), 'each', [], ($CallNode$25 = function(operator, name){var self = $CallNode$25.$$s == null ? this : $CallNode$25.$$s, $$26;

        
          
          if (operator == null) {
            operator = nil;
          };
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'add_special', [operator.$to_sym()], ($$26 = function(compile_default){var self = $$26.$$s == null ? this : $$26.$$s, $a, lhs = nil, rhs = nil;

          
            
            if (compile_default == null) {
              compile_default = nil;
            };
            if ($truthy(self.$compiler()['$inline_operators?']())) {
              
              if ($truthy(self['$record_method?']())) {
                self.$compiler().$method_calls()['$<<'](operator.$to_sym())};
              self.$compiler().$operator_helpers()['$<<'](operator.$to_sym());
              $a = [self.$expr(self.$recvr()), self.$expr(self.$arglist())], (lhs = $a[0]), (rhs = $a[1]), $a;
              self.$push(self.$fragment("" + "$rb_" + (name) + "("));
              self.$push(lhs);
              self.$push(self.$fragment(", "));
              self.$push(rhs);
              return self.$push(self.$fragment(")"));
            } else {
              return compile_default.$call()
            };}, $$26.$$s = self, $$26.$$arity = 1, $$26));}, $CallNode$25.$$s = self, $CallNode$25.$$arity = 2, $CallNode$25));
        $send(self, 'add_special', ["require"], ($CallNode$27 = function(compile_default){var self = $CallNode$27.$$s == null ? this : $CallNode$27.$$s, str = nil;

        
          
          if (compile_default == null) {
            compile_default = nil;
          };
          str = $$($nesting, 'DependencyResolver').$new(self.$compiler(), self.$arglist().$children()['$[]'](0)).$resolve();
          if ($truthy(str['$nil?']())) {
          } else {
            self.$compiler().$requires()['$<<'](str)
          };
          return compile_default.$call();}, $CallNode$27.$$s = self, $CallNode$27.$$arity = 1, $CallNode$27));
        $send(self, 'add_special', ["require_relative"], ($CallNode$28 = function(){var self = $CallNode$28.$$s == null ? this : $CallNode$28.$$s, arg = nil, file = nil, dir = nil;

        
          arg = self.$arglist().$children()['$[]'](0);
          file = self.$compiler().$file();
          if (arg.$type()['$==']("str")) {
            
            dir = $$($nesting, 'File').$dirname(file);
            self.$compiler().$requires()['$<<'](self.$Pathname(dir).$join(arg.$children()['$[]'](0)).$cleanpath().$to_s());};
          self.$push(self.$fragment("" + "self.$require(" + (file.$inspect()) + "+ '/../' + "));
          self.$push(self.$process(self.$arglist()));
          return self.$push(self.$fragment(")"));}, $CallNode$28.$$s = self, $CallNode$28.$$arity = 0, $CallNode$28));
        $send(self, 'add_special', ["autoload"], ($CallNode$29 = function(compile_default){var self = $CallNode$29.$$s == null ? this : $CallNode$29.$$s, str = nil;

        
          
          if (compile_default == null) {
            compile_default = nil;
          };
          if ($truthy(self.$scope()['$class_scope?']())) {
            
            str = $$($nesting, 'DependencyResolver').$new(self.$compiler(), self.$arglist().$children()['$[]'](1)).$resolve();
            if ($truthy(str['$nil?']())) {
            } else {
              self.$compiler().$requires()['$<<'](str)
            };
            return compile_default.$call();
          } else {
            return nil
          };}, $CallNode$29.$$s = self, $CallNode$29.$$arity = 1, $CallNode$29));
        $send(self, 'add_special', ["require_tree"], ($CallNode$30 = function(compile_default){var self = $CallNode$30.$$s == null ? this : $CallNode$30.$$s, $a, first_arg = nil, rest = nil, relative_path = nil, dir = nil, full_path = nil;

        
          
          if (compile_default == null) {
            compile_default = nil;
          };
          $a = [].concat(Opal.to_a(self.$arglist().$children())), (first_arg = ($a[0] == null ? nil : $a[0])), (rest = $slice.call($a, 1)), $a;
          if (first_arg.$type()['$==']("str")) {
            
            relative_path = first_arg.$children()['$[]'](0);
            self.$compiler().$required_trees()['$<<'](relative_path);
            dir = $$($nesting, 'File').$dirname(self.$compiler().$file());
            full_path = self.$Pathname(dir).$join(relative_path).$cleanpath().$to_s();
            full_path.$force_encoding(relative_path.$encoding());
            first_arg = first_arg.$updated(nil, [full_path]);};
          self.arglist = self.$arglist().$updated(nil, $rb_plus([first_arg], rest));
          return compile_default.$call();}, $CallNode$30.$$s = self, $CallNode$30.$$arity = 1, $CallNode$30));
        $send(self, 'add_special', ["block_given?"], ($CallNode$31 = function(){var self = $CallNode$31.$$s == null ? this : $CallNode$31.$$s;
          if (self.sexp == null) self.sexp = nil;

        return self.$push(self.$compiler().$handle_block_given_call(self.sexp))}, $CallNode$31.$$s = self, $CallNode$31.$$arity = 0, $CallNode$31));
        $send(self, 'add_special', ["__callee__"], ($CallNode$32 = function(){var self = $CallNode$32.$$s == null ? this : $CallNode$32.$$s;

        if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))
          } else {
            return self.$push(self.$fragment("nil"))
          }}, $CallNode$32.$$s = self, $CallNode$32.$$arity = 0, $CallNode$32));
        $send(self, 'add_special', ["__method__"], ($CallNode$33 = function(){var self = $CallNode$33.$$s == null ? this : $CallNode$33.$$s;

        if ($truthy(self.$scope()['$def?']())) {
            return self.$push(self.$fragment(self.$scope().$mid().$to_s().$inspect()))
          } else {
            return self.$push(self.$fragment("nil"))
          }}, $CallNode$33.$$s = self, $CallNode$33.$$arity = 0, $CallNode$33));
        $send(self, 'add_special', ["debugger"], ($CallNode$34 = function(){var self = $CallNode$34.$$s == null ? this : $CallNode$34.$$s;

        return self.$push(self.$fragment("debugger"))}, $CallNode$34.$$s = self, $CallNode$34.$$arity = 0, $CallNode$34));
        $send(self, 'add_special', ["__OPAL_COMPILER_CONFIG__"], ($CallNode$35 = function(){var self = $CallNode$35.$$s == null ? this : $CallNode$35.$$s;

        return self.$push(self.$fragment("" + "Opal.hash({ arity_check: " + (self.$compiler()['$arity_check?']()) + " })"))}, $CallNode$35.$$s = self, $CallNode$35.$$arity = 0, $CallNode$35));
        $send(self, 'add_special', ["nesting"], ($CallNode$36 = function(compile_default){var self = $CallNode$36.$$s == null ? this : $CallNode$36.$$s, push_nesting = nil;

        
          
          if (compile_default == null) {
            compile_default = nil;
          };
          push_nesting = self['$push_nesting?']();
          if ($truthy(push_nesting)) {
            self.$push("(Opal.Module.$$nesting = $nesting, ")};
          compile_default.$call();
          if ($truthy(push_nesting)) {
            return self.$push(")")
          } else {
            return nil
          };}, $CallNode$36.$$s = self, $CallNode$36.$$arity = 1, $CallNode$36));
        $send(self, 'add_special', ["constants"], ($CallNode$37 = function(compile_default){var self = $CallNode$37.$$s == null ? this : $CallNode$37.$$s, push_nesting = nil;

        
          
          if (compile_default == null) {
            compile_default = nil;
          };
          push_nesting = self['$push_nesting?']();
          if ($truthy(push_nesting)) {
            self.$push("(Opal.Module.$$nesting = $nesting, ")};
          compile_default.$call();
          if ($truthy(push_nesting)) {
            return self.$push(")")
          } else {
            return nil
          };}, $CallNode$37.$$s = self, $CallNode$37.$$arity = 1, $CallNode$37));
        
        Opal.def(self, '$push_nesting?', $CallNode_push_nesting$ques$38 = function() {
          var self = this, recv = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

          
          recv = self.$children().$first();
          if ($truthy(($ret_or_8 = self.$children().$size()['$=='](2)))) {
            
            if ($truthy(($ret_or_9 = recv['$nil?']()))) {
              return $ret_or_9
            } else {
              
              if ($truthy(($ret_or_10 = recv.$type()['$==']("const")))) {
                return recv.$children().$last()['$==']("Module")
              } else {
                return $ret_or_10
              };
            };
          } else {
            return $ret_or_8
          };
        }, $CallNode_push_nesting$ques$38.$$arity = 0);
        return (function($base, $super, $parent_nesting) {
          var self = $klass($base, $super, 'DependencyResolver');

          var $nesting = [self].concat($parent_nesting), $DependencyResolver_initialize$39, $DependencyResolver_resolve$40, $DependencyResolver_handle_part$41, $DependencyResolver_expand_path$43;

          self.$$prototype.sexp = self.$$prototype.compiler = nil;
          
          
          Opal.def(self, '$initialize', $DependencyResolver_initialize$39 = function $$initialize(compiler, sexp) {
            var self = this;

            
            self.compiler = compiler;
            return (self.sexp = sexp);
          }, $DependencyResolver_initialize$39.$$arity = 2);
          
          Opal.def(self, '$resolve', $DependencyResolver_resolve$40 = function $$resolve() {
            var self = this;

            return self.$handle_part(self.sexp)
          }, $DependencyResolver_resolve$40.$$arity = 0);
          
          Opal.def(self, '$handle_part', $DependencyResolver_handle_part$41 = function $$handle_part(sexp) {
            var $a, $b, $$42, self = this, type = nil, recv = nil, meth = nil, args = nil, parts = nil, $ret_or_11 = nil, $ret_or_12 = nil, msg = nil, $case = nil;

            
            type = sexp.$type();
            if (type['$==']("str")) {
              return sexp.$children()['$[]'](0)
            } else if (type['$==']("send")) {
              
              $b = sexp.$children(), $a = Opal.to_ary($b), (recv = ($a[0] == null ? nil : $a[0])), (meth = ($a[1] == null ? nil : $a[1])), (args = $slice.call($a, 2)), $b;
              parts = $send(args, 'map', [], ($$42 = function(s){var self = $$42.$$s == null ? this : $$42.$$s;

              
                
                if (s == null) {
                  s = nil;
                };
                return self.$handle_part(s);}, $$42.$$s = self, $$42.$$arity = 1, $$42));
              if ($truthy((function() {if ($truthy(($ret_or_11 = (function() {if ($truthy(($ret_or_12 = recv['$is_a?']($$$($$$($$$('::', 'Opal'), 'AST'), 'Node'))))) {
                return recv.$type()['$==']("const")
              } else {
                return $ret_or_12
              }; return nil; })()))) {
                return recv.$children().$last()['$==']("File")
              } else {
                return $ret_or_11
              }; return nil; })())) {
                if (meth['$==']("expand_path")) {
                  return $send(self, 'expand_path', Opal.to_a(parts))
                } else if (meth['$==']("join")) {
                  return self.$expand_path(parts.$join("/"))
                } else if (meth['$==']("dirname")) {
                  return self.$expand_path(parts['$[]'](0).$split("/")['$[]']($range(0, -1, true)).$join("/"))}};};
            msg = "Cannot handle dynamic require";
            return (function() {$case = self.compiler.$dynamic_require_severity();
            if ("error"['$===']($case)) {return self.compiler.$error(msg, self.sexp.$line())}
            else if ("warning"['$===']($case)) {return self.compiler.$warning(msg, self.sexp.$line())}
            else { return nil }})();
          }, $DependencyResolver_handle_part$41.$$arity = 1);
          return (Opal.def(self, '$expand_path', $DependencyResolver_expand_path$43 = function $$expand_path(path, base) {
            var $$44, self = this;

            
            
            if (base == null) {
              base = "";
            };
            return $send(((("" + (base)) + "/") + (path)).$split("/"), 'each_with_object', [[]], ($$44 = function(part, p){var self = $$44.$$s == null ? this : $$44.$$s;

            
              
              if (part == null) {
                part = nil;
              };
              
              if (p == null) {
                p = nil;
              };
              if (part['$==']("")) {
                return nil
              } else if (part['$==']("..")) {
                return p.$pop()
              } else {
                return p['$<<'](part)
              };}, $$44.$$s = self, $$44.$$arity = 2, $$44)).$join("/");
          }, $DependencyResolver_expand_path$43.$$arity = -2), nil) && 'expand_path';
        })($nesting[0], null, $nesting);
      })($nesting[0], $$($nesting, 'Base'), $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
})(Opal);
